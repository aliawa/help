" Testing scripts
" ----------------------------
save script as .vim file
run script with ':source <filename>' or ':so %'



" Echo
" ----------------------------
echo  "shell=" &shell                  disappears after redraw
echom "it's a zizzer zazzer zuzz"      can be seen later with :messages


" Setting options
"-----------------------------
:set number                            
:set number?                           check current value of option
:set number!                           toggle a boolean option
:set numberwidth=40                    set a non-boolean option
:setlocal number                       set option for this buffer only


" Mapping, never use map, nmap, vmap, imap because they are recursive
"-----------------------------
:noremap <c-d> dd                      normal and visual mode Ctrl+d mapped to dd
:noremap <space> viw                   normal and visual mode Space-key mapped to "select word"
:nnoremap \ dd                         normal mode only
:vnoremap \ U                          visual mode only, upper case selection
:inoremap <c-d> <esc>ddi               insert mode mapping, delete line
:nmap                                  show normal-mode key mapping
:nnoremap <buffer> <leader>x dd        key mapping for this buffer only


" operator pending mapping
" ----------------------------
:onoremap p i(                        now dp will delete parameters inside the '(' and ')'



" abbriviations
" ----------------------------
iabbrev waht what                      works in insert mode only


" Autocommands
" ----------------------------
:autocmd BufNewFile * :write           event to watch for BufNewFile
                                       filter for event for example *.txt
                                       The command to run :write
:help autocmd-events

:autocmd BufNewFile,BufRead *.html setlocal nowrap
                                       Multiple events 




" Other
" ----------------------------
exists(g:syntax_on) " is global variable 'syntax_on' defined?

<CR>                " carriage return see more unprintable-characters :help keycodes
<silent>            " after nmap, causes the mapping not to echo any commands it is executing
s/\<./\u&/g         " upper case first letter of word


" line continuation marker: single backslash at the start of line
call SetName(
\             first_name,
\             middle_initial,
\             family_name
\           )
" multiple commands in a single line
echo "Starting..." | call Phase(1) | call Phase(2) | echo "Done"




" Variables
" ----------------------------

" assignment
let name = "Damian"
let height = 165
let interests =  'Cinema', 'Literature', 'World Domination', 101 
let phone     = { 'cell':5551017346, 'home':5558038728, 'work':'?' }


" Variable scoping
g:varname     global
s:varname     local to the current script file
w:varname     local to the current editor window
t:varname     local to the current editor tab
b:varname     local to the current editor buffer
l:varname     local to the current function
a:varname     a parameter of the current function
v:varname     predefined by Vim


" pseudovriables, you can treat options registers as variables
&varname       A Vim option (local option if defined, otherwise global)
&l:varname     A local Vim option
&g:varname     A global Vim option
@varname       A Vim register
$varname       An environment variable 



" Conditionals
" ------------------------------

" if, else, elseif
:if 0
:    echom "if"
:elseif "nope!"
:    echom "elseif"
:else
:    echom "finally!"
:endif

" ternary if
&tabstop > 1 ? 1 : 0


" Operators
" ------------------------------
Operation                           Operator syntax
Assignment                          let var = expr
Numeric-add-and-assign              let var += expr
Numeric-subtract-and-assign         let var –= expr
String-concatenate-and-assign       let var .= expr

Ternary operator                    bool ? expr-if-true : expr-if-false
Logical OR                          bool || bool
Logical AND                         bool && bool
Numeric addition                    num+num
Numeric subtraction                 num–num
String concatenation                str.str
Numeric multiplication              num*num
Numeric division                    num/num
Numeric modulus                     num%num
Convert to number                   +num
Numeric negation                    –num
Logical NOT                         !bool
Parenthetical precedence            ( expr )


" comparison never use bare comparison operators because they are afected by 
" user setting, use the explicit ones
Numeric or string equality          expr==expr
Numeric or string inequality        expr!=expr
Numeric or string greater-then      expr>expr
Numeric or string greater-or-equal  expr>=expr
Numeric or string less than         expr<expr
Numeric or string less-or-equal     expr<=expr
case insensitive comparison         name ==? 'Batman'       
case sensitive comparison           name <# 'ee cummings'
:help expr4


" Functions
" --------------------------------

function Meow()                     "Name must start with uppercase
    echom "Mewo!"
    return "Meow String!"
endfunction

call  Meow()                        " calling 
echom GetMeow()                     " calling in expression, 'call' not needed

" function arguments
function DisplayName(name)
    echom a:name                    " use 'a:' prefix to refer to arguments
endfunction

" varargs
function Varg(...)
    echom a:0                       " number of varargs
    echom a:1                       " first vararg
    echo a:000                      " all varargs as list
endfunction

" built-in functions
:help functions
:help function-list



" Strings
" ---------------------------------
" concat
"Hello" . "World"

"special charaters
:help expr-quote

echom '\n\\'                        " literal string, special characters not evaluated

strlen("foo")                       " 3
len("foo")                          " 3
split("one two three")              " ['one', 'two', 'three']
split("one,two,three", ",")         " ['one', 'two', 'three']
join(["foo", "bar"], "...")         " foo...bar
join(split("foo bar"), ";")         " foo;bar
tolower("Foo")
toupper("Foo")
:help functions

"abcd"[0:2]                         " abc
"abcd"[-2:]                         " cd





" Normal
" ---------------------------------
Always use normal! because plane normal takes mappings into account

" normal does not understand <cr> <esc> etc.
:execute "normal! mqA;\<esc>`q"



" Grep
" ---------------------------------
" grep the word 
:nnoremap <leader>g :silent execute "grep! -R " .  shellescape(expand("<cWORD>")) . " ."<cr>:copen<cr>


" Registers
" ---------------------------------
"saving yank register at the begining of script and restoring it at end
let saved_unnammed_reg = @@
let @@ = saved_unnammed_reg


" List
" ---------------------------------
['foo', 3, 'bar']
['a', 'b', 'c', 'd', 'e'] [0:2]                 " ['a','b','c']
['a', 'b', 'c', 'd', 'e'] [0:10000]             " entire list 
['a', 'b', 'c', 'd', 'e'][:1]                   " ['a', 'b']
['a', 'b', 'c', 'd', 'e'][3:]                   " ['d', 'e']
['a', 'b'] + ['c']                              " ['a','b','c']

let foo = ['a']
call add(foo, 'b')
echo foo                                        " ['a','b']
len(foo)                                        " 2
index(foo, 'b')                                 " 1
join(foo)                                       " ab
join(foo, '---')                                " a---b
reverse(foo)                                    "['b', 'a']


" Loops
" ---------------------------------
let c = 0
for i in [1, 2, 3, 4]
  let c += i
endfor

let c = 1
let total = 0
while c <= 4
  let total += c
  let c += 1
endwhile


" Dictionaries
" ---------------------------------
{'a': 1, 100: 'foo',}['a']                  " 1
{'a': 1, 100: 'foo',}.100                   " foo
let foo.a = 100
let foo.b = 200                             " {'a': 100, 'b': 200}
let test = remove(foo, 'a')                 " test = 100
unlet foo.b                                 " 

get({'a': 100}, 'a', 'default')             " 100
get({'a': 100}, 'b', 'default')             " default
has_key({'a': 100}, 'a')                    " 1
items({'a': 100, 'b': 200})                 " [['a', 100], ['b', 200]]
keys()
values()



" Paths
" ---------------------------------
expand('%')                                 " relative path of current file
expand('%:p')                               " absolute path of current file
fnamemodify('foo.txt', ':p')                " absolute path of foo.txt
globpath('.', '*')                          " all files and dirs in current dir
split(globpath('.', '*.txt'), '\n')         " all txt files as list



" Namespace
" ---------------------------------
function general#DeleteTrailingWS() abort
    normal mz
    %s/\v\s+$//ge
    normal `z
endfunc

When you call the function with :call general#DeleteTrailingWS(),
Vim will:
- Look inside the autoload directory for a file called general.
- Search for a function called DeleteTrailingWS inside this file.
- Load and execute the function.



" Examples
" ---------------------------------

" change each line use as: :1,3call Change_lines('50')
function! g:Change_lines(val)
    call setline('.', substitute(getline('.'), '\d\+$', a:val, ''))
endfunction


" change last digits on each line in range
function! g:Change_lines(val) range
    let l:lnum = a:firstline
    let l:val= a:val
    while l:lnum < a:lastline
        call setline(l:lnum, substitute(getline(l:lnum), '\d\+$', l:val, ''))
        let l:val+=1
        let l:lnum+=1
    endwhile
endfunction





