#! /bin/bash

# Variables
# -----------------------------------------------------------------
${#string}                 # String Length
${string:position}         # Extracts substring starting at $position.(position starts at 0)
${string:position:length}  # Extracts $length characters starting at $position.
${string#substring}        # Deletes shortest match of $substring from front
${string##substring}       # Deletes longest match of $substring from front
${string%substring}        # Deletes shortest match of $substring from back
${string%%substring}       # Deletes longest match of $substring from back
${alpha/find/replace}      # Search and replace first occurance
${alpha//find/replace}     # Search and replace all occurance

${string/#substring/replacement}  
                           # If $substring matches front end of $string, 
                           # substitute $replacement for $substring.
${string/%substring/replacement}  
                           # If $substring matches back end of $string, 
                           # substitute $replacement for $substring.


# Misc
# -----------------------------------------------------------------
# using input by lines
ls -F | while read i; do ...; done

# Does START_ADDR match a hexadecimal number
[[ ! "$START_ADDR" =~ ^[0]?[xX]?[0-9A-Fa-f][0-9A-Fa-f]*$ ]]

# First arg of command is variable
git ls-files --others --exclude-standard | while read -r i; do cp --parents $i ~/tmp; done

# using xagrs with initial argumenst
git ls-files --others --exclude-standard | xargs -I{} cp --parents {} ~/tmp


# ANSI Escape Sequences for writing text in "BOLD" and "UNDERLINE" . 
# -----------------------------------------------------------------
# Bold
echo -e "\033[1mThis is a BOLD line\033[0m"
# Underline
echo -e "\033[4mThis is a underlined line.\033[0m"

tput bold; echo "bold text"   # print bold
tput sgr0; echo "normal text" # reset to normal

# All escape sequences
http://ascii-table.com/ansi-escape-sequences-vt-100.php

# readable format
bold=`tput bold`
normal=`tput sgr0`
echo "this is ${bold}bold${normal} but this isn't"




# here-is document
# -----------------------------------------------------------------
cat << End-Of-Msg
---------------------
This is line 1 of the messge
This is line 2 of the message
---------------------
End-Of-Msg

# here-is document with parameter substitution turned off
cat << 'End-Of-Msg'
---------------------
This is line 1: My dir is $HOME
This is line 2: cd $PTOP
---------------------
End-Of-Msg



# Bracket expansion
#------------------
echo file1.{cpp,c,h,hxx}   # produces : file1.cpp file1.c file1.h file1.hxx


# kill job number one
#---------------------
kill -9 %1


# redirect shortcut
#-----------------
cmd > file.txt 2>&1
cmd &> file.txt






#----------------------
#     command line
#---------------------
previous-history (C-p)
    Fetch the previous command from the history list, moving back in the list. 
next-history (C-n)
    Fetch the next command from the history list, moving forward in the list. 
beginning-of-history (M-<)
    Move to the first line in the history. 
end-of-history (M->)
    Move to the end of the input history, i.e., the line currently being entered. 
reverse-search-history (C-r)
    Search backward starting at the current line and moving 'up' through the history as necessary. This is an incremental search. 
forward-search-history (C-s)
    Search forward starting at the current line and moving 'down' through the history as necessary. This is an incremental search. 
non-incremental-reverse-search-history (M-p)
    Search backward through the history starting at the current line using a non-incremental search for a string supplied by the user. 
non-incremental-forward-search-history (M-n)
    Search forward through the history using a non-incremental search for a string supplied by the user.
yank-nth-arg (M-C-y)
    Insert the first argument to the previous command (usually the second word on the previous line) at point. With an argument n, insert the nth word from the previous command (the words in the previous command begin with word 0). A negative argument inserts the nth word from the end of the previous command. Once the argument n is computed, the argument is extracted as if the "!n" history expansion had been specified.
yank-last-arg (M-., M-_)
    Insert the last argument to the previous command (the last word of the previous history entry). With an argument, behave exactly like yank-nth-arg. Successive calls to yank-last-arg move back through the history list, inserting the last argument of each line in turn. The history expansion facilities are used to extract the last argument, as if the "!$" history expansion had been specified. 
shell-expand-line (M-C-e)
    Expand the line as the shell does. This performs alias and history expansion as well as all of the shell word expansions. See HISTORY EXPANSION below for a description of history expansion. 
history-expand-line (M-^)
    Perform history expansion on the current line. See HISTORY EXPANSION below for a description of history expansion.
insert-last-argument (M-., M-_)
    A synonym for yank-last-arg. 
operate-and-get-next (C-o)
    Accept the current line for execution and fetch the next line relative to the current line from the history for editing. Any argument is ignored. 
edit-and-execute-command (C-xC-e)
    Invoke an editor on the current command line, and execute the result as shell commands.



# read
str="ali awais street 95050 ca usa"
read _ last _ zip _ _ <<< "$str"
echo "$last, $zip"



#-------------------------------------------
# see all bash defines
#-------------------------------------------

bash -v


#-------------------------------------------
# map "jk" in vi mode
#-------------------------------------------
$if mode=vi

    set keymap vi-command
    "jk": vi-insertion-mode

    set keymap vi-insert
    "jk": vi-movement-mode

$endif 



#-------------------------------------------
# history
#-------------------------------------------

# make typed command as the previous command
append !:p

# repeat last command with sudo
sudo !!

# reuse the last argument of the last command
cd !$

# reuse the first argument of the last command
nano !^

# reuse the nth argument of the last command
nano !:<n>

# search last command with keyword and execute
!<keyword>

# resuse second argument of the command containiing keyword
ls !<keyword>:2




#-------------------------------------------
# Detect if script is running in background
#-------------------------------------------
# $$ = PID of current process
case $(ps -o stat= -p $$) in
    *+*) echo "Running in foreground" ;;
      *) echo "Running in background" ;;
esac



#-------------------------------------------
# Redirect stdout to a file
#-------------------------------------------
exec 2>errors.txt


#-------------------------------------------
# mkdir -p examples
#-------------------------------------------
mkdir -p /home/john/Downloads/web
mkdir -p Downloads/{active-torrents,finished-torrents,web}
mkdir -p johnbokma.com/{branches,tags,trunk/{cgi-bin,htdocs,scripts}}


