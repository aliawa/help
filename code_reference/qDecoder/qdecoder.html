
word
known

word
known

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-------------------------------------------------------------->
<!-- The qDecoder Project             http://www.qDecoder.org -->
<!--                                   ftp://ftp.qDecoder.org -->
<!--                                                          -->
<!--         Copyright (C) 2001 The qDecoder Project.         -->
<!--         Copyright (C) 1999 Hongik Internet, Inc.         -->
<!--         Copyright (C) 1998 Nobreak Technologies, Inc.    -->
<!--         Copyright (C) 1996,1997 Seung-young Kim          -->
<!-------------------------------------------------------------->

<html>
<head>
  <title>The qDecoder Project: qDecoder Function Reference</title>
  <meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
  <meta name="DESCRIPTION" content="qDecoder, CGI, Web Application Interface, C, C++, Library">
  <link rel="stylesheet" href="/include/default.css" type="text/css">
</head>

<body bgcolor="white" background="/gifs/bgimage.gif" "marginwidth="30">

<center>
<table border="0" width="90%"><tr>
  <td align="center">
    <a href="http://www.qDecoder.org/"><img src="/gifs/powerlogo.gif" border="0" alt="The qDecoder Project"></a>
  </td>
</tr></table>
<hr width="100%" noshade>
</center>

<h2><font color="#00aa00">qDecoder Function Reference</font></h2>
<br clear="all"><ul>
  <p><li>Query and Cookie Handling Functions
  <ul>
    <li><a name='toc-qDecoder()' href='#qDecoder()'>qDecoder()</a>
    <li><a name='toc-qValue()' href='#qValue()'>qValue()</a>
    <li><a name='toc-qiValue()' href='#qiValue()'>qiValue()</a>
    <li><a name='toc-qValueDefault()' href='#qValueDefault()'>qValueDefault()</a>
    <li><a name='toc-qValueNotEmpty()' href='#qValueNotEmpty()'>qValueNotEmpty()</a>
    <li><a name='toc-qValueReplace()' href='#qValueReplace()'>qValueReplace()</a>
    <li><a name='toc-qGetFirstEntry()' href='#qGetFirstEntry()'>qGetFirstEntry()</a>
    <li><a name='toc-qValueFirst()' href='#qValueFirst()'>qValueFirst()</a>
    <li><a name='toc-qValueNext()' href='#qValueNext()'>qValueNext()</a>
    <li><a name='toc-qValueAdd()' href='#qValueAdd()'>qValueAdd()</a>
    <li><a name='toc-qValueRemove()' href='#qValueRemove()'>qValueRemove()</a>
    <li><a name='toc-qValueType()' href='#qValueType()'>qValueType()</a>
    <li><a name='toc-qCookieSet()' href='#qCookieSet()'>qCookieSet()</a>
    <li><a name='toc-qCookieRemove()' href='#qCookieRemove()'>qCookieRemove()</a>
    <li><a name='toc-qCookieValue()' href='#qCookieValue()'>qCookieValue()</a>
    <li><a name='toc-qPrint()' href='#qPrint()'>qPrint()</a>
    <li><a name='toc-qFree()' href='#qFree()'>qFree()</a>
  </ul>
  <p><li>Session Functions
  <ul>
    <li><a name='toc-qSession()' href='#qSession()'>qSession()</a>
    <li><a name='toc-qSessionAdd()' href='#qSessionAdd()'>qSessionAdd()</a>
    <li><a name='toc-qSessionAddInteger()' href='#qSessionAddInteger()'>qSessionAddInteger()</a>
    <li><a name='toc-qSessionUpdateInteger()' href='#qSessionUpdateInteger()'>qSessionUpdateInteger()</a>
    <li><a name='toc-qSessionValue()' href='#qSessionValue()'>qSessionValue()</a>
    <li><a name='toc-qSessionValueInteger()' href='#qSessionValueInteger()'>qSessionValueInteger()</a>
    <li><a name='toc-qSessionRemove()' href='#qSessionRemove()'>qSessionRemove()</a>
    <li><a name='toc-qSessionGetID()' href='#qSessionGetID()'>qSessionGetID()</a>
    <li><a name='toc-qSessionGetCreated()' href='#qSessionGetCreated()'>qSessionGetCreated()</a>
    <li><a name='toc-qSessionSetTimeout()' href='#qSessionSetTimeout()'>qSessionSetTimeout()</a>
    <li><a name='toc-qSessionPrint()' href='#qSessionPrint()'>qSessionPrint()</a>
    <li><a name='toc-qSessionSave()' href='#qSessionSave()'>qSessionSave()</a>
    <li><a name='toc-qSessionFree()' href='#qSessionFree()'>qSessionFree()</a>
    <li><a name='toc-qSessionDestroy()' href='#qSessionDestroy()'>qSessionDestroy()</a>
  </ul>
  <p><li>Configuration File Parsing Functions
  <ul>
    <li><a name='toc-qfDecoder()' href='#qfDecoder()'>qfDecoder()</a>
    <li><a name='toc-qfValue()' href='#qfValue()'>qfValue()</a>
    <li><a name='toc-qfiValue()' href='#qfiValue()'>qfiValue()</a>
    <li><a name='toc-qfValueFirst()' href='#qfValueFirst()'>qfValueFirst()</a>
    <li><a name='toc-qfValueNext()' href='#qfValueNext()'>qfValueNext()</a>
    <li><a name='toc-qfPrint()' href='#qfPrint()'>qfPrint()</a>
    <li><a name='toc-qfFree' href='#qfFree'>qfFree</a>
  </ul>
  <p><li>Configuration String Parsing Functions
  <ul>
    <li><a name='toc-qsDecoder()' href='#qsDecoder()'>qsDecoder()</a>
    <li><a name='toc-qsValue()' href='#qsValue()'>qsValue()</a>
    <li><a name='toc-qsiValue()' href='#qsiValue()'>qsiValue()</a>
    <li><a name='toc-qsValueFirst()' href='#qsValueFirst()'>qsValueFirst()</a>
    <li><a name='toc-qsValueNext()' href='#qsValueNext()'>qsValueNext()</a>
    <li><a name='toc-qsPrint()' href='#qsPrint()'>qsPrint()</a>
    <li><a name='toc-qsFree' href='#qsFree'>qsFree</a>
  </ul>
  <p><li>SED: Context Generation Functions
  <ul>
name
    <li><a name='toc-qsValueNext()' href='#qsValueNext()'>qsValueNext()</a>
    <li><a name='toc-qsPrint()' href='#qsPrint()'>qsPrint()</a>
    <li><a name='toc-qsFree' href='#qsFree'>qsFree</a>
  </ul>
  <p><li>SED: Context Generation Functions
toc
    <li><a name='toc-qSedArgAdd()' href='#qSedArgAdd()'>qSedArgAdd()</a>
    <li><a name='toc-qSedArgAddDirect()' href='#qSedArgAddDirect()'>qSedArgAddDirect()</a>
    <li><a name='toc-qSedArgPrint()' href='#qSedArgPrint()'>qSedArgPrint()</a>
    <li><a name='toc-qSedArgFree()' href='#qSedArgFree()'>qSedArgFree()</a>
    <li><a name='toc-qSedFile()' href='#qSedFile()'>qSedFile()</a>
    <li><a name='toc-qSedStr()' href='#qSedStr()'>qSedStr()</a>
  </ul>
  <p><li>AWK: Pattern Scanning Functions
  <ul>
    <li><a name='toc-qAwkOpen()' href='#qAwkOpen()'>qAwkOpen()</a>
    <li><a name='toc-qAwkNext()' href='#qAwkNext()'>qAwkNext()</a>
    <li><a name='toc-qAwkClose()' href='#qAwkClose()'>qAwkClose()</a>
    <li><a name='toc-qAwkStr()' href='#qAwkStr()'>qAwkStr()</a>
  </ul>
  <p><li>Search Key Words & Pattern Matching Functions
  <ul>
    <li><a name='toc-qArgMake()' href='#qArgMake()'>qArgMake()</a>
    <li><a name='toc-qArgMatch()' href='#qArgMatch()'>qArgMatch()</a>
    <li><a name='toc-qArgEmprint()' href='#qArgEmprint()'>qArgEmprint()</a>
    <li><a name='toc-qArgPrint()' href='#qArgPrint()'>qArgPrint()</a>
    <li><a name='toc-qArgFree()' href='#qArgFree()'>qArgFree()</a>
  </ul>
  <p><li>HTTP Response Functions
  <ul>
    <li><a name='toc-qContentType()' href='#qContentType()'>qContentType()</a>
    <li><a name='toc-qGetContentFlag()' href='#qGetContentFlag()'>qGetContentFlag()</a>
    <li><a name='toc-qResetContentFlag()' href='#qResetContentFlag()'>qResetContentFlag()</a>
    <li><a name='toc-qRedirect()' href='#qRedirect()'>qRedirect()</a>
    <li><a name='toc-qJavaScript()' href='#qJavaScript()'>qJavaScript()</a>
  </ul>
  <p><li>Encoding/decoding Functions
  <ul>
    <li><a name='toc-qURLencode()' href='#qURLencode()'>qURLencode()</a>
    <li><a name='toc-qURLdecode' href='#qURLdecode'>qURLdecode</a>
    <li><a name='toc-qMD5Str()' href='#qMD5Str()'>qMD5Str()</a>
    <li><a name='toc-qMD5File()' href='#qMD5File()'>qMD5File()</a>
    <li><a name='toc-qFnv32Hash()' href='#qFnv32Hash()'>qFnv32Hash()</a>
  </ul>
  <p><li>String Handling Functions
  <ul>
    <li><a name='toc-qPrintf()' href='#qPrintf()'>qPrintf()</a>
    <li><a name='toc-qPuts()' href='#qPuts()'>qPuts()</a>
    <li><a name='toc-qRemoveSpace()' href='#qRemoveSpace()'>qRemoveSpace()</a>
    <li><a name='toc-qRemoveTailSpace' href='#qRemoveTailSpace'>qRemoveTailSpace</a>
    <li><a name='toc-qStrReplace()' href='#qStrReplace()'>qStrReplace()</a>
    <li><a name='toc-qStr09AZaz()' href='#qStr09AZaz()'>qStr09AZaz()</a>
    <li><a name='toc-qStrupr()' href='#qStrupr()'>qStrupr()</a>
    <li><a name='toc-qStrlwr()' href='#qStrlwr()'>qStrlwr()</a>
    <li><a name='toc-qStristr()' href='#qStristr()'>qStristr()</a>
    <li><a name='toc-qStricmp()' href='#qStricmp()'>qStricmp()</a>
    <li><a name='toc-qStrincmp()' href='#qStrincmp()'>qStrincmp()</a>
    <li><a name='toc-qitocomma()' href='#qitocomma()'>qitocomma()</a>
    <li><a name='toc-qStrcat()' href='#qStrcat()'>qStrcat()</a>
    <li><a name='toc-qStrdupBetween()' href='#qStrdupBetween()'>qStrdupBetween()</a>
  </ul>
  <p><li>File Handling Functions
  <ul>
    <li><a name='toc-qfopen()' href='#qfopen()'>qfopen()</a>
    <li><a name='toc-qfclose()' href='#qfclose()'>qfclose()</a>
    <li><a name='toc-qCheckFile()' href='#qCheckFile()'>qCheckFile()</a>
    <li><a name='toc-qCatFile()' href='#qCatFile()'>qCatFile()</a>
    <li><a name='toc-qReadFile()' href='#qReadFile()'>qReadFile()</a>
    <li><a name='toc-qSaveStr()' href='#qSaveStr()'>qSaveStr()</a>
    <li><a name='toc-qFileSize()' href='#qFileSize()'>qFileSize()</a>
    <li><a name='toc-qfGetLine()' href='#qfGetLine()'>qfGetLine()</a>
    <li><a name='toc-qfGets()' href='#qfGets()'>qfGets()</a>
    <li><a name='toc-qCmd()' href='#qCmd()'>qCmd()</a>
  </ul>
  <p><li>Validation Functions
  <ul>
    <li><a name='toc-qCheckEmail()' href='#qCheckEmail()'>qCheckEmail()</a>
    <li><a name='toc-qCheckURL()' href='#qCheckURL()'>qCheckURL()</a>
  </ul>
  <p><li>Download Handling Functions
  <ul>
    <li><a name='toc-qDownload()' href='#qDownload()'>qDownload()</a>
    <li><a name='toc-qDownloadMime()' href='#qDownloadMime()'>qDownloadMime()</a>
  </ul>
  <p><li>Counter Handling Functions
  <ul>
    <li><a name='toc-qCountRead()' href='#qCountRead()'>qCountRead()</a>
    <li><a name='toc-qCountSave()' href='#qCountSave()'>qCountSave()</a>
    <li><a name='toc-qCountUpdate()' href='#qCountUpdate()'>qCountUpdate()</a>
  </ul>
  <p><li>Environment Related Functions
  <ul>
    <li><a name='toc-qCGIenv()' href='#qCGIenv()'>qCGIenv()</a>
    <li><a name='toc-qCGIname()' href='#qCGIname()'>qCGIname()</a>
    <li><a name='toc-qGetenvDefault()' href='#qGetenvDefault()'>qGetenvDefault()</a>
  </ul>
  <p><li>Time Functions
  <ul>
    <li><a name='toc-qGetTime()' href='#qGetTime()'>qGetTime()</a>
    <li><a name='toc-qGetGMTime()' href='#qGetGMTime()'>qGetGMTime()</a>
    <li><a name='toc-qGetTimeStr()' href='#qGetTimeStr()'>qGetTimeStr()</a>
  </ul>
  <p><li>Socket Handling Functions
  <ul>
    <li><a name='toc-qSocketOpen()' href='#qSocketOpen()'>qSocketOpen()</a>
    <li><a name='toc-qSocketClose()' href='#qSocketClose()'>qSocketClose()</a>
    <li><a name='toc-qSocketWaitReadable()' href='#qSocketWaitReadable()'>qSocketWaitReadable()</a>
    <li><a name='toc-qSocketRead()' href='#qSocketRead()'>qSocketRead()</a>
    <li><a name='toc-qSocketGets()' href='#qSocketGets()'>qSocketGets()</a>
    <li><a name='toc-qSocketWrite()' href='#qSocketWrite()'>qSocketWrite()</a>
    <li><a name='toc-qSocketPuts()' href='#qSocketPuts()'>qSocketPuts()</a>
    <li><a name='toc-qSocketPrintf()' href='#qSocketPrintf()'>qSocketPrintf()</a>
    <li><a name='toc-qSocketSendFile()' href='#qSocketSendFile()'>qSocketSendFile()</a>
    <li><a name='toc-qSocketSaveIntoFile()' href='#qSocketSaveIntoFile()'>qSocketSaveIntoFile()</a>
    <li><a name='toc-qSocketSetNonblock()' href='#qSocketSetNonblock()'>qSocketSetNonblock()</a>
    <li><a name='toc-qSocketConv2file()' href='#qSocketConv2file()'>qSocketConv2file()</a>
  </ul>
  <p><li>Database Independent Wrapper Functions
  <ul>
    <li><a name='toc-qDbInit()' href='#qDbInit()'>qDbInit()</a>
    <li><a name='toc-qDbOpen()' href='#qDbOpen()'>qDbOpen()</a>
    <li><a name='toc-qDbClose()' href='#qDbClose()'>qDbClose()</a>
    <li><a name='toc-qDbGetErrMsg()' href='#qDbGetErrMsg()'>qDbGetErrMsg()</a>
    <li><a name='toc-qDbPing()' href='#qDbPing()'>qDbPing()</a>
    <li><a name='toc-qDbGetLastConnStatus()' href='#qDbGetLastConnStatus()'>qDbGetLastConnStatus()</a>
    <li><a name='toc-qDbExecuteUpdate()' href='#qDbExecuteUpdate()'>qDbExecuteUpdate()</a>
    <li><a name='toc-qDbExecuteQuery()' href='#qDbExecuteQuery()'>qDbExecuteQuery()</a>
    <li><a name='toc-qDbGetRows()' href='#qDbGetRows()'>qDbGetRows()</a>
    <li><a name='toc-qDbGetCols()' href='#qDbGetCols()'>qDbGetCols()</a>
    <li><a name='toc-qDbResultNext()' href='#qDbResultNext()'>qDbResultNext()</a>
    <li><a name='toc-qDbResultFree()' href='#qDbResultFree()'>qDbResultFree()</a>
    <li><a name='toc-qDbGetValue()' href='#qDbGetValue()'>qDbGetValue()</a>
    <li><a name='toc-qDbGetInt()' href='#qDbGetInt()'>qDbGetInt()</a>
    <li><a name='toc-qDbGetValueAt()' href='#qDbGetValueAt()'>qDbGetValueAt()</a>
    <li><a name='toc-qDbGetIntAt()' href='#qDbGetIntAt()'>qDbGetIntAt()</a>
    <li><a name='toc-qDbBeginTran()' href='#qDbBeginTran()'>qDbBeginTran()</a>
    <li><a name='toc-qDbEndTran()' href='#qDbEndTran()'>qDbEndTran()</a>
    <li><a name='toc-qDbCommit()' href='#qDbCommit()'>qDbCommit()</a>
    <li><a name='toc-qDbRollback()' href='#qDbRollback()'>qDbRollback()</a>
  </ul>
  <p><li>Log Handling Functions
  <ul>
    <li><a name='toc-qLogOpen()' href='#qLogOpen()'>qLogOpen()</a>
    <li><a name='toc-qLogClose()' href='#qLogClose()'>qLogClose()</a>
    <li><a name='toc-qLogSetConsole()' href='#qLogSetConsole()'>qLogSetConsole()</a>
    <li><a name='toc-qLogFlush()' href='#qLogFlush()'>qLogFlush()</a>
    <li><a name='toc-qLog()' href='#qLog()'>qLog()</a>
  </ul>
  <p><li>Error Handling Functions
  <ul>
    <li><a name='toc-qError()' href='#qError()'>qError()</a>
    <li><a name='toc-qErrorContact()' href='#qErrorContact()'>qErrorContact()</a>
    <li><a name='toc-qErrorLog()' href='#qErrorLog()'>qErrorLog()</a>
  </ul>
  <p><li>Miscellaneous Functions
  <ul>
    <li><a name='toc-qFreeAll()' href='#qFreeAll()'>qFreeAll()</a>
    <li><a name='toc-qReset()' href='#qReset()'>qReset()</a>
    <li><a name='toc-qUniqueID()' href='#qUniqueID()'>qUniqueID()</a>
  </ul>
</ul>

<hr size='1' noshade>
<p><h3><a name='qDecoder.c'>Query and Cookie Handling Functions</a></h3>
<p><a name='qDecoder()' href='#toc-qDecoder()' class='plain'><b><font size='3'>qDecoder()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDecoder(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Interprets encoded query strings and stores them in the linked-list. COOKIE, GET, POST(including multipart/form-data encoding) are supported.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the number of received arguments. In case of failure, return -1.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The parsing sequence is (1)COOKIE (2)GET (3)POST. Thus if same query names (which are sent by different method) exist, qValue() will return the value of COOKIE.<br>
<br>
This function, qDecoder(), is called automatically when you use qValue() or related functions, so you do not need to call directly.<br>
<br>
In case of multipart/form-data encoding(used for file uploading), the variables of &quot;variable_name.length&quot;, &quot;variable_name.contenttype&quot; and &quot;variable_name.name&quot; are automatically inserted. The number of bytes of data is stored in &quot;variable_name.length&quot;, and the content type of data is stored in &quot;variable_name.contenttype&quot; and the file names(file name itself, path information will be removed) transmitted by users are stored in &quot;variable_name.name&quot;. (In case of &quot;C:Data\a.gif&quot;, only &quot;a.gif&quot; is stored.) In counter of return values, a total of 4 lists are stored but since the 4 lists are for one data, they are regarded as 1 list.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Example 1: application/x-www-form-urlencoded (GET/POST Method)

[HTML]
<form method="post" action="input.cgi">
  User ID <input type="text" name="userID"><br>
  <input type="submit">
</form>

[Parsed Queries]
name  = "userID"
value = "character strings users input"

[C]
#include <stdio.h>
#include "qDecoder.h"
void main(void) {
  char *id;
  qContentType("text/html");
  id = qValue("userID");
  printf("%s", id);
}

Example 2: multipart/form-data 

[HTML]
<form method="post" action="upload.cgi" enctype="multipart/form-data">
  User ID <input type="text" name="userID"><br>
  Attachment <input type="file" name="binary"><br>
  <input type="submit">
</form>

[Parsed Queries]
name  = "userID"
value = "character strings users input"

name  = "binary"
value = "binary data of a.gif"
name  = "binary.length"
value = "128"
name  = "binary.filename"
value = "a.gif"

[C]
#include <stdio.h>
#include <stdlib.h>
#include "qDecoder.h"

void main(void) {
  FILE *fp;
  char *userID;
  char *filedata, *filename;
  int  filelength, i;

  qContentType("text/plain");

  userID = qValue("userID");

  filedata   = qValue("binary");
  filelength = qiValue("binary.length");
  filename   = qValue("binary.filename");

  fp = fopen(filename, "wb");
  for(i = filelength; i > 0; i--) fprintf(fp, "%c", *(filedata++));
  fclose(fp);

  printf("%s : %s(%s bytes) saved.", userID, filename, filelength);
}</xmp></td></tr>
</table>
<p><a name='qValue()' href='#toc-qValue()' class='plain'><b><font size='3'>qValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qValue(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Finds out the value (COOKIE, GET, POST) for variable names at the linked-list and hands over the pointers.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The pointer of the variable value if a variable name exists. NULL if there is no variable name.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>qValue() returns only the pointers of query index created by qDecoder().Accordingly, you should not free() the pointers received at qValue. The deallocation of allocated memory should be performed through the qFree() function (generally before the program is shut down). <br>
<br>
Internally calls qDecoder if qDecoder() has not been called before.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *test;
test = qValue("VARIABLE NAME");

char *test;
int i = 1;
test = qValue("COUNT.%d", i);</xmp></td></tr>
</table>
<p><a name='qiValue()' href='#toc-qiValue()' class='plain'><b><font size='3'>qiValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qiValue(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Same as that of qValue(). But this returns the value(numeric character string) after converting it into integers.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the integer value for the variable value (numericcharacter string). If a variable name does not exist or cannot be converted, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int test;
test = qiValue("VARIABLE NAME");

int test, i = 1;
test = qValue("COUNT.%d", i);</xmp></td></tr>
</table>
<p><a name='qValueDefault()' href='#toc-qValueDefault()' class='plain'><b><font size='3'>qValueDefault()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qValueDefault(char *defstr, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This is a simple function of qValue() used for setting up a primary argument when there is no query.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as that of qValue(). But this returns the pointer of defstr when there is no query.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>value = qValueDefault("Seoul", "COUNTRY");</xmp></td></tr>
</table>
<p><a name='qValueNotEmpty()' href='#toc-qValueNotEmpty()' class='plain'><b><font size='3'>qValueNotEmpty()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qValueNotEmpty(char *errmsg, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays specified error messages by using the qError() function when there is no query or blank character strings (&quot;&quot;) are returned.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as qValue except that it has &quot;error handling&quot; within for NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>value = qValueNotEmpty("Enter country name", "COUNTRY");</xmp></td></tr>
</table>
<p><a name='qValueReplace()' href='#toc-qValueReplace()' class='plain'><b><font size='3'>qValueReplace()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qValueReplace(char *mode, char *name, char *tokstr, char *word);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Transposes tokens and character strings for the linked-list character strings.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Transposed character-string pointers.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Basically, qValueReplace() is the wrapping function of qStrReplace(). The difference is that the source character string is the query value (the value of the linked-list for names) in it, and the conversion can be directly done to the linked-list itself. <br>
Accordingly, the usage of arguments of qValueReplace() is basically the same as that of qStrReplace(). <br>
<br>
The 'name' argument is the query name of the linked-list to be used as source character strings. And it is the source character string to be used when the corresponding value is transposed. <br>
<br>
The 'mode' argument is a character string made up of two separate characters like &quot;sr&quot;. <br>
<br>
The first character defines the transposition method. 't' or 's' can be located in its place. 't' stands for [t]oken. It compares the source character strings (the value character string of the linked-list for given names) using each character of the tokstr character string as a token and transposes the matching characters into a word character string. 's' stands for [s]tring. It transposes into a word character string the tokstr matching character strings appearing inside the source string using the tokstr string itself as a token. <br>
<br>
The second character stands for the recording type of the transposed character string. Eigher 'n' or 'r' can be used for it. 'n' stands for [n]ew. It makes the corresponding pointer returned by storing the transposed result character string in a new memory space. Accordingly, the source string linked-list should be maintained in its original state, and the pertinent memory needs to be free() from the user's aspect. 'r' stands for [r]eplace and means overwriting the transposition results on the linked-list itself. This is accomplished through the internal reallocation of memory. <br>
<br>
As a result, there are 4 possible occasions in which the 'mode' argument can be assembled. <br>
<br>
 &nbsp;Mode &quot;tn&quot; : [t]oken transposition & stores results in a [n]ew space and returns<br>
 &nbsp;Mode &quot;tr&quot; : [t]oken transposition & [r]eplaces the linked-list itself<br>
 &nbsp;Mode &quot;sn&quot; : [s]tring transposition & stores results in a [n]ew space and returns<br>
 &nbsp;Mode &quot;sr&quot; : [s]tring transposition & [r]eplaces the linked-list itself</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Example 1)
  char *retstr, *mode;
  mode = qValue("mode");
  qContentType("text/plain");

  printf("before %s : srcstr = %s\n", mode, qValue("srcstr"));
  retstr = qValueReplace(mode, "srcstr", "hello", "[?]");
  printf("after  %s : srcstr = %s\n", mode, qValue("srcstr"));
  printf("            retstr = %s\n\n", retstr);
  if(mode[1] == 'n') free(retstr);
  return 0;

Result 'tn')
  before tn : srcstr = hello world
  after  tn : srcstr = hello world
              retstr = [?][?][?][?][?] w[?]r[?]d

Result 'tr')
  before tr : srcstr = hello world
  after  tr : srcstr = [?][?][?][?][?] w[?]r[?]d
              retstr = [?][?][?][?][?] w[?]r[?]d

Result 'sn')
  before sn : srcstr = hello world
  after  sn : srcstr = hello world
              retstr = [?] world

Result 'sr')
  before sr : srcstr = hello world
  after  sr : srcstr = [?] world
              retstr = [?] world</xmp></td></tr>
</table>
<p><a name='qGetFirstEntry()' href='#toc-qGetFirstEntry()' class='plain'><b><font size='3'>qGetFirstEntry()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_Entry *qGetFirstEntry(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Returns the first Q_Entry pointer of the linked-list.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>If there is stored data in linked-list, return Q_Entry first pointer. Or return NULL.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>This is used to acquire a root pointer when the linked-list used by qDecoder() is to be directly manipulated.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_Entry *first;
first = qGetFirstEntry();</xmp></td></tr>
</table>
<p><a name='qValueFirst()' href='#toc-qValueFirst()' class='plain'><b><font size='3'>qValueFirst()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qValueFirst(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Used for patching the arguments having an identical variable name inregular sequence.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the first variable-value pointer for the arguments having an identical variable name. If there is no variable name, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *list;
for(list = qValueFirst("checklist"); list; list = qValueNext()) {
  printf("checklist = %s<br>\n", list);
}</xmp></td></tr>
</table>
<p><a name='qValueNext()' href='#toc-qValueNext()' class='plain'><b><font size='3'>qValueNext()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qValueNext(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Continues to find out with qValueFirst().</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the pointer of the variable value. If there is no more identical variable name, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *list;
for(list = qValueFirst("checklist"); list; list = qValueNext()) {
  printf("checklist = %s<br>\n", list);
}</xmp></td></tr>
</table>
<p><a name='qValueAdd()' href='#toc-qValueAdd()' class='plain'><b><font size='3'>qValueAdd()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qValueAdd(char *name, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Force to add given name and value to linked list.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>String pointer of added entry in linked-list.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>If same name exists, it'll be replaced.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qValueAdd("NAME", "Seung-young Kim");
name = qValue("NAME");</xmp></td></tr>
</table>
<p><a name='qValueRemove()' href='#toc-qValueRemove()' class='plain'><b><font size='3'>qValueRemove()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qValueRemove(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Remove entry from linked list.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qValueRemove("NAME");</xmp></td></tr>
</table>
<p><a name='qValueType()' href='#toc-qValueType()' class='plain'><b><font size='3'>qValueType()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char qValueType(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Returns type(Cookie, GET, POST) of query.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Cookie `C`, Get method `G`, Post method `P`, New data(qValueAdd) &nbsp;`N`, Not found `-`.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>switch(qValueType(name)) {
  case 'C' : { cookie_cnt++; break; }
  case 'G' : { get_cnt++; break; }
  case 'P' : { post_cnt++; break; }
  case 'N' : { new_cnt++; break; }
}</xmp></td></tr>
</table>
<p><a name='qCookieSet()' href='#toc-qCookieSet()' class='plain'><b><font size='3'>qCookieSet()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qCookieSet(char *name, char *value, int exp_days, char *path, char *domain, char *secure);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Sets up those cookies that correspond to name=value.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>When cookies are set up through qCookieSet(), the point of time when values are handed over through qValue() is when the next program is called. In some implementations, however, cookies need to be set up for the simplicity of logic while, at the same time, this needs to be applied to other routines. In this case, qValueAdd() can prevent the alteration of logic and the waste of additional codes by adding values to the cookie linked-list. But with regard to qCookieSet(), setting up cookies at clients (browsers) does not succeed always. Thus, users should be careful when using qValueAdd(). <br>
<br>
This should be used before qContentType() is called.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *name = "NAME", *value = "Kim";

// Apply the NAME=Kim information in the current domain and directory for 30 days.
qCookieSet(name, value, 30, NULL, NULL, NULL);

// Apply the NAME=Kim information to the "/" directory of "ANYTHING.qdecoder.org" 
// until the browser is shut down.
qCookieSet(name, value, 0, "/", ".qdecoder.org", NULL);

// As for the followings, cookies will be set up only when security
// requirements are satisfied.
qCookieSet(name, value, 0, NULL, NULL, "SECURE");

// As for the followings, you can remove cookies.
qCookieSet(name, "", -1, NULL, NULL, NULL);</xmp></td></tr>
</table>
<p><a name='qCookieRemove()' href='#toc-qCookieRemove()' class='plain'><b><font size='3'>qCookieRemove()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qCookieRemove(char *name, char *path, char *domain, char *secure);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Remove cookie from client(browser).</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The arguments(path, domain, secure) must be exactly same as the arguments of qCookieSet().<br>
<br>
When cookies are removed through qCookieRemove(), the point of time when values in linked-list removed is when the next program is called. In some implementations, however, cookies need to be removed for the simplicity of logic while, at the same time, this needs to be applied to other routines. In this case, qValueRemove() can prevent the alteration of logic and the waste of additional codes by removing values to the linked-list. But with regard to qCookieRemove(), removing cookies at clients (browsers) does not succeed always. Thus, users should be careful when using qValueRemove().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qCookieSet("NAME", "VALUE", 0, NULL, NULL, NULL);
qCookieRemove("NAME", NULL, NULL, NULL);

qCookieSet("NAME", "VALUE", 0, "/", NULL, NULL);
qCookieRemove("NAME", "/", NULL, NULL);

qCookieSet("NAME", "VALUE", 0, "/", "www.qdecoder.org", NULL);
qCookieRemove("NAME", "/", "www.qdecoder.org", NULL);</xmp></td></tr>
</table>
<p><a name='qCookieValue()' href='#toc-qCookieValue()' class='plain'><b><font size='3'>qCookieValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qCookieValue(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Return cookie value.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The pointer of the cookie value if a cookie name exists. NULL if there is no cookie name.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *cookie;

cookie = qCookieValue("NAME");
if(cookie == NULL) qError("Cookies are not set.");</xmp></td></tr>
</table>
<p><a name='qPrint()' href='#toc-qPrint()' class='plain'><b><font size='3'>qPrint()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qPrint(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays all the arguments transmitted for the purpose of debugging programs.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The number of arguments.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qPrint();</xmp></td></tr>
</table>
<p><a name='qFree()' href='#toc-qFree()' class='plain'><b><font size='3'>qFree()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qValueAdd(char *name, char *value);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Deallocates the allocated memory by qDecoder().</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Please refer qFreeAll() too.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qFree();</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qSession.c'>Session Functions</a></h3>
<p><a name='qSession()' href='#toc-qSession()' class='plain'><b><font size='3'>qSession()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSession(char *repository);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Start Session.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>New session 1, else 0.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>To use session, you must call qSession() at the start. qSession() stores 32 bytes session id to client using cookie, then stores session data to server side. By default, session data will be expired in 1800 seconds since last access. You can adjust this period by using qSessionSetTimeout().<br>
<br>
To use session on clients which does not support cookie such like WAP phone.<br>
add QSESSIONID into your link below.<br>
<br>
http://domain/application?QSESSIONID=ab77bbb49dd61cd510db121a948ab4d9&other=arguments<br>
<br>
qSession() will store default session values below.<br>
<br>
 &nbsp;_Q_SESSIONID &nbsp;&nbsp;: Session ID (ex: ab77bbb49dd61cd510db121a948ab4d9)<br>
 &nbsp;_Q_CREATED-GMT : Created GMT Time (ex: Thu, 19-Jul-2001 21:50:19 GMT)<br>
 &nbsp;_Q_CREATED &nbsp;&nbsp;&nbsp;&nbsp;: Created Time (ex: 995579419)<br>
 &nbsp;_Q_CONNECTIONS : Connection Count (ex: 15)<br>
 &nbsp;_Q_INTERVAL &nbsp;&nbsp;&nbsp;: Expire Period/Seconds (ex: 1800)<br>
<br>
Session data is stored in filesystem(unix: &quot;/tmp&quot;, win32: &quot;C:\Windows\Temp&quot;).<br>
You can change storage path using argument 'repository' when you call qSession(). qSession() generates &quot;qsession-&quot; prefixed files in session storage and manage automatically. (In case of WIN32 environment, the session files in repository are not managed automatically, so you would better to clean periodically repository)<br>
<br>
Session data will be stored when qSessionFree(), qSessionSave() or qFreeAll() is called.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSession(NULL);   // use default storage
qSession("/tmp"); // use /tmp for session storage</xmp></td></tr>
</table>
<p><a name='qSessionAdd()' href='#toc-qSessionAdd()' class='plain'><b><font size='3'>qSessionAdd()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qSessionAdd(char *name, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Add session value.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Stored String pointer of value.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionAdd("name", "qDecoder");
qSessionAdd("cginame", "%s", qCGIname());</xmp></td></tr>
</table>
<p><a name='qSessionAddInteger()' href='#toc-qSessionAddInteger()' class='plain'><b><font size='3'>qSessionAddInteger()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSessionAddInteger(char *name, int valueint);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Add session value of integer type.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Stored integer value.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionAddInteger("count", 32);</xmp></td></tr>
</table>
<p><a name='qSessionUpdateInteger()' href='#toc-qSessionUpdateInteger()' class='plain'><b><font size='3'>qSessionUpdateInteger()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSessionUpdateInteger(char *name, int plusint);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Update session value of integer type.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Updated integer value.</td></tr>
</table>
<p><a name='qSessionValue()' href='#toc-qSessionValue()' class='plain'><b><font size='3'>qSessionValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qSessionValue(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Return session value.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Success pointer of value string, Fail NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *value;
value = qSessionValue("name");
value = qSessionValue("%d.name", i);</xmp></td></tr>
</table>
<p><a name='qSessionValueInteger()' href='#toc-qSessionValueInteger()' class='plain'><b><font size='3'>qSessionValueInteger()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSessionValueInteger(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Return session value of integer type.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Success integer of value, Fail 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int value;
value = qSessionValueInteger("count");</xmp></td></tr>
</table>
<p><a name='qSessionRemove()' href='#toc-qSessionRemove()' class='plain'><b><font size='3'>qSessionRemove()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qSessionRemove(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Remove session variable.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionRemove("name");
qSessionRemove("%d.name", i);</xmp></td></tr>
</table>
<p><a name='qSessionGetID()' href='#toc-qSessionGetID()' class='plain'><b><font size='3'>qSessionGetID()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qSessionGetID(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Return current session id.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>String pointer of session id(32bytes).</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *sessionid;
char *sessionidstr[32+1];

sessionid = qSessionGetID();
strcpy(sessionidstr, sessionid);</xmp></td></tr>
</table>
<p><a name='qSessionGetCreated()' href='#toc-qSessionGetCreated()' class='plain'><b><font size='3'>qSessionGetCreated()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>time_t qSessionGetCreated(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Return session created time in seconds.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Value of created time in seconds since 0 hours, 0 minutes, 0 seconds, January 1, 1970.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>time_t created;
struct tm *gmtime;
created = qSessionGetCreated();
gmtime = gmtime(&created);</xmp></td></tr>
</table>
<p><a name='qSessionSetTimeout()' href='#toc-qSessionSetTimeout()' class='plain'><b><font size='3'>qSessionSetTimeout()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qSessionSetTimeout(time_t seconds);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Change current session expiration period.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>New expiration period.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>By default, expiration period is 1800 seconds.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionSetTimeout((time_t)3600);</xmp></td></tr>
</table>
<p><a name='qSessionPrint()' href='#toc-qSessionPrint()' class='plain'><b><font size='3'>qSessionPrint()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSessionPrint(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays all the session variables for the purpose of debugging programs.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The number of variables.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionPrint();</xmp></td></tr>
</table>
<p><a name='qSessionSave()' href='#toc-qSessionSave()' class='plain'><b><font size='3'>qSessionSave()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qSessionSave(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Save session data immediately.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>qSessionSave() will be automatically called, when you callqSessionFree() at the end of program. If program can be quitted before qSessionFree(), you can use<br>
qSessionSave() directly to protect session data.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionSave();</xmp></td></tr>
</table>
<p><a name='qSessionFree()' href='#toc-qSessionFree()' class='plain'><b><font size='3'>qSessionFree()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qSessionFree(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Save session data and deallocate memories.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionFree();</xmp></td></tr>
</table>
<p><a name='qSessionDestroy()' href='#toc-qSessionDestroy()' class='plain'><b><font size='3'>qSessionDestroy()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qSessionDestroy(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Destroy current session.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSessionDestroy();</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qfDecoder.c'>Configuration File Parsing Functions</a></h3>
<p><a name='qfDecoder()' href='#toc-qfDecoder()' class='plain'><b><font size='3'>qfDecoder()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_Entry *qfDecoder(char *filename);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Reads file and stores in the linked-list. (no limitations to the line length of files)</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The first record pointer of the linked-list, NULL in case of failure.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Reads the file of the following format and stores them in the linked-list. <br>
<br>
---- test.conf ----<br>
# this is comment.<br>
name &nbsp;= Seung-young Kim<br>
age &nbsp;&nbsp;= 30<br>
addr &nbsp;= Korea<br>
-------------------<br>
<br>
Regarded as explanatory notes, those lines starting with sharps(#) are not interpreted.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_Entry *first;
first = qfDecoder("test.conf");
if(first == NULL) qError("File not found.");</xmp></td></tr>
</table>
<p><a name='qfValue()' href='#toc-qfValue()' class='plain'><b><font size='3'>qfValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qfValue(Q_Entry *first, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Acquires the variable value of variable names.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the pointer of the variable value. In case of failure, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *value;
value = qfValue(first, "name");</xmp></td></tr>
</table>
<p><a name='qfiValue()' href='#toc-qfiValue()' class='plain'><b><font size='3'>qfiValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qfiValue(Q_Entry *first, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Converts the variable values into integers and hands them over.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, reurns the integer value for the variable value (numericcharacter strings). When a variable name does not exist or the pertinent value cannot be convertedinto integers, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int count;
count = qfiValue(first, "count");</xmp></td></tr>
</table>
<p><a name='qfValueFirst()' href='#toc-qfValueFirst()' class='plain'><b><font size='3'>qfValueFirst()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qfValueFirst(Q_Entry *first, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Used for patching the arguments having an identical variable name inregular sequence.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the first variable-value pointer for the arguments having an identical variable name. If there is no variable name, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *list;
for(list = qfValueFirst("checklist"); list; list = qfValueNext()) {
  printf("checklist = %s<br>\n", list);
}</xmp></td></tr>
</table>
<p><a name='qfValueNext()' href='#toc-qfValueNext()' class='plain'><b><font size='3'>qfValueNext()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qfValueNext(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Continues to find out with qfValueFirst().</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the pointer of the variable value. If there is no more identical variable name, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *list;
for(list = qfValueFirst("checklist"); list; list = qfValueNext()) {
  printf("checklist = %s<br>\n", list);
}</xmp></td></tr>
</table>
<p><a name='qfPrint()' href='#toc-qfPrint()' class='plain'><b><font size='3'>qfPrint()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qfPrint(Q_Entry *first);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays all the interpreted arguments for debugging programs.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The number of arguments.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qfPrint(first);</xmp></td></tr>
</table>
<p><a name='qfFree' href='#toc-qfFree' class='plain'><b><font size='3'>qfFree</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qfFree(Q_Entry *first);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Deallocates allocated memory.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qfFree(first);</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qsDecoder.c'>Configuration String Parsing Functions</a></h3>
<p><a name='qsDecoder()' href='#toc-qsDecoder()' class='plain'><b><font size='3'>qsDecoder()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_Entry *qsDecoder(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Reads string and stores in the linked-list. (no limitations to the line length of files)</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The first record pointer of the linked-list, NULL in case of failure.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Reads the file of the following format and stores them in the linked-list. <br>
<br>
---- test.conf ----<br>
# this is comment.<br>
name &nbsp;= Seung-young Kim<br>
age &nbsp;&nbsp;= 30<br>
addr &nbsp;= Korea<br>
-------------------<br>
<br>
Regarded as explanatory notes, those lines starting with sharps(#) are not interpreted.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_Entry *FirstRecord;
char *str="name=Seung-young Kim\nage=26\naddr=Korea";
FirstRecord = qsDecoder(str);</xmp></td></tr>
</table>
<p><a name='qsValue()' href='#toc-qsValue()' class='plain'><b><font size='3'>qsValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qsValue(Q_Entry *first, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Acquires the variable value of variable names.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the pointer of the variable value. In case of failure, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *value;
value = qsValue(first, "name");</xmp></td></tr>
</table>
<p><a name='qsiValue()' href='#toc-qsiValue()' class='plain'><b><font size='3'>qsiValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qsiValue(Q_Entry *first, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Converts the variable values into integers and hands them over.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, reurns the integer value for the variable value (numericcharacter strings). When a variable name does not exist or the pertinent value cannot be convertedinto integers, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int count;
count = qsiValue(first, "count");</xmp></td></tr>
</table>
<p><a name='qsValueFirst()' href='#toc-qsValueFirst()' class='plain'><b><font size='3'>qsValueFirst()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qsValueFirst(Q_Entry *first, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Used for patching the arguments having an identical variable name inregular sequence.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the first variable-value pointer for the arguments having an identical variable name. If there is no variable name, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *list;
for(list = qsValueFirst("checklist"); list; list = qsValueNext()) {
  printf("checklist = %s<br>\n", list);
}</xmp></td></tr>
</table>
<p><a name='qsValueNext()' href='#toc-qsValueNext()' class='plain'><b><font size='3'>qsValueNext()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qsValueNext(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Continues to find out with qfValueFirst().</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the pointer of the variable value. If there is no more identical variable name, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *list;
for(list = qsValueFirst("checklist"); list; list = qsValueNext()) {
  printf("checklist = %s<br>\n", list);
}</xmp></td></tr>
</table>
<p><a name='qsPrint()' href='#toc-qsPrint()' class='plain'><b><font size='3'>qsPrint()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qsPrint(Q_Entry *first);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays all the interpreted arguments for debugging programs.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The number of arguments.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qsPrint(first);</xmp></td></tr>
</table>
<p><a name='qsFree' href='#toc-qsFree' class='plain'><b><font size='3'>qsFree</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qsFree(Q_Entry *first);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Deallocates allocated memory.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qsFree(first);</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qSed.c'>SED: Context Generation Functions</a></h3>
<p><a name='qSedArgAdd()' href='#toc-qSedArgAdd()' class='plain'><b><font size='3'>qSedArgAdd()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_Entry *qSedArgAdd(Q_Entry *first, char *name, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Add a variable to argument list for use of qSedFile() and qSedStr().</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Pointer of argument list.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_Entry *args;

args = NULL;
args = qSedArgAdd(args, "${NAME}", "%s", "Seung-young Kim"); /* recommanded */
args = qSedArgAdd(args, "${HOBBY}", Playing Guitar"); /* not recommanded, but it works */</xmp></td></tr>
</table>
<p><a name='qSedArgAddDirect()' href='#toc-qSedArgAddDirect()' class='plain'><b><font size='3'>qSedArgAddDirect()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_Entry *qSedArgAddDirect(Q_Entry *first, char *name, char *value);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Add a variable with huge data to argument list for use of qSedFile() and qSedStr().</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>First pointer of argument list.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>This function is same as qSedArg() except the value string is not formatted. So you can use value string which size is bigger than 1024-1 bytes.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_Entry *args;
char *hugevalue = "...huge...string...";

args = NULL;
args = qSedArgAddDirect(args, "${NAME}", hugevalue);</xmp></td></tr>
</table>
<p><a name='qSedArgPrint()' href='#toc-qSedArgPrint()' class='plain'><b><font size='3'>qSedArgPrint()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSedArgPrint(Q_Entry *first);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays all the variables for debugging programs.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The number of arguments.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSedArgPrint(first);</xmp></td></tr>
</table>
<p><a name='qSedArgFree()' href='#toc-qSedArgFree()' class='plain'><b><font size='3'>qSedArgFree()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qSedArgFree(Q_Entry *first);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Deallocates allocated memory by qSedArgAdd().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSedArgFree(first);</xmp></td></tr>
</table>
<p><a name='qSedFile()' href='#toc-qSedFile()' class='plain'><b><font size='3'>qSedFile()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSedFile(Q_Entry *first, char *filename, FILE *fpout);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Replaces specified symbols with defined character strings in files and displays them. And supports part of the SSI grammar.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns 1. When files cannot be opened, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Plays a similar function to the SED command of UNIX systems. <br>
<br>
---- ex) streamedit.html.in ----<br>
&lt;!--#include file=&quot;streamedit-header.html.in&quot;--&gt;<br>
&lt;p&gt;Hi &lt;b&gt;${NAME}&lt;/b&gt;.<br>
&lt;p&gt;You got a really cool hobby.<br>
&lt;br&gt;I'm sure that your hobby, &lt;b&gt;${HOBBY}&lt;/b&gt;, can make your life more compatible.<br>
&lt;p&gt;Bye :)<br>
&lt;!--#include file=&quot;streamedit-tailer.html.in&quot;--&gt;<br>
---------------------<br>
<br>
By utilizing qSedFile, CGI programming can be performed even without including HTML codes in the programs. Thus, UI-related debugging time can be reduced to a great extent, and the design and development works can be separately performed. Package products can be easily customized by users. <br>
filename is an input(target) file while fpout stands for output streams. When you wish to display the results in files, open files in &quot;w&quot; and then, hand over the corresponding file pointers. And if you wish to display them on-screen, just specify stdout. <br>
<br>
It interprets the SSI grammar. (Currently, only [an error occurred while processing this directive] is supported.) If there is the following lines in a document, the corresponding document is included in the display. And the replacement and SSI functions are valid for the included document. (Cascading) <br>
<br>
&lt;!--#include file=&quot;streamedit-header.html.in&quot;--&gt;<br>
<br>
Note) The included file can be marked by relative paths on the basis of the location where CGI is executed. Or it may be marked by system absolute paths. <br>
<br>
If you wish to use the SSI function only without replacing character strings, transmit the NULL value using the arg argument as follows: <br>
<br>
ex) qSedFile(NULL, &quot;streamedit.html.in&quot;, stdout);</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_Entry *args;
char *name, *hobby;

qContentType("text/html");

name = qValueDefault("Not Found", "name");
hobby = qValueDefault("Not Found", "hobby");

args = NULL;
args = qSedArgAdd(args, "${NAME}", name);
args = qSedArgAdd(args, "${HOBBY}", hobby);

if(qSedFile(args, "streamedit.html.in", stdout) == 0) qError("File not found.");

qSedArgFree(args);</xmp></td></tr>
</table>
<p><a name='qSedStr()' href='#toc-qSedStr()' class='plain'><b><font size='3'>qSedStr()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSedStr(Q_Entry *first, char *srcstr, FILE *fpout);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Plays same functions as qSedFile(), but input is done in character strings.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as that of qSedFile().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_Entry *args;
char *sp;

sp = "My name is ${NAME}.";
args = NULL;
args = qSedArgAdd(args, "${NAME}", "Seung-young Kim");

qSedStr(args, sp, stdout);

qSedArgFree(args);</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qAwk.c'>AWK: Pattern Scanning Functions</a></h3>
<p><a name='qAwkOpen()' href='#toc-qAwkOpen()' class='plain'><b><font size='3'>qAwkOpen()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qAwkOpen(char *filename, char separator);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Opens files and sets up delimiters.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns 1. When files cannot be opened, return 0.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Plays a similar function to the AWK command of UNIX systems. <br>
<br>
---- ex) /etc/passwd ----<br>
shpark:x:1008:1000:Sang-hyun Park:/home/shpark:/bin/csh<br>
teamwork:x:1011:1000:Seung-young Kim:/home/teamwork:/bin/csh<br>
kikuchi:x:1015:2000:KIKUCHI:/home/kikuchi:/bin/csh<br>
-------------------------</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qAwkOpen("/etc/passwd", ':');</xmp></td></tr>
</table>
<p><a name='qAwkNext()' href='#toc-qAwkNext()' class='plain'><b><font size='3'>qAwkNext()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qAwkNext(char array[][1024]);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Reads a line and stores it in an array given as a argument.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the number of fields. The end of files, -1.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>There is no limitation to the length of lines. But each field should not exceed 1024-1 bytes.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char array[7][1024];
qAwkOpen("/etc/passwd", ':');
for( ; qAwkNext(array) > 0; ) printf("ID=%s, Name=%s", array[0], array[5]);
qAwkClose();</xmp></td></tr>
</table>
<p><a name='qAwkClose()' href='#toc-qAwkClose()' class='plain'><b><font size='3'>qAwkClose()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qAwkClose(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Closes open files.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns 1. When there is no open file, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qAwkClose();</xmp></td></tr>
</table>
<p><a name='qAwkStr()' href='#toc-qAwkStr()' class='plain'><b><font size='3'>qAwkStr()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qAwkStr(char array[][1024], char *str, char delim);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Reads a string and stores it in an array given as a argument.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>returns the number of fields.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>There is no limitation to the length of lines. But each field should not exceed 1024-1 bytes.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *string = "root:*:0:0:Charlie &:/root:/bin/csh";
char array[7][1024];

qAwkStr(array, string, ':');</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qArg.c'>Search Key Words & Pattern Matching Functions</a></h3>
<p><a name='qArgMake()' href='#toc-qArgMake()' class='plain'><b><font size='3'>qArgMake()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qArgMake(char *str, char **qlist);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Divides queries into tokens. The delimiters are generally space characters. And the redundant spaces between tokens and the spaces before and after queries are disregarded.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The number of divided tokens.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>A group of functions related to search words classifies query character strings on the basis of spaces and double quotation marks(&quot;) and then, stores them in the lists. And it provides a group of functions connected with the matching tests and display of target character strings. <br>
<br>
<br>
---- Example ----<br>
Query Input: I am a &quot;pretty girl&quot;<br>
-----------------<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;|<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V &nbsp;V<br>
---- qArgMake() ----<br>
qlist[0] = I<br>
qlist[1] = am<br>
qlist[2] = a<br>
qlist[3] = pretty girl<br>
qlist[4] = NULL<br>
Return: 4 (4 Tokens)<br>
--------------------<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;|<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V &nbsp;V<br>
---- qArgPrint() ----<br>
'I' (1 bytes)<br>
'am' (2 bytes)<br>
'a' (1 bytes)<br>
'pretty girl' (11 bytes)<br>
---------------------<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;|<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V &nbsp;V<br>
---- qArgMatch() ----<br>
Target String: Hi, I'm a pretty boy. Are you pretty girl?<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &nbsp;= &nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;===========<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &nbsp;0 &nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>
Return: 3 (3 matches: qlist[0], qlist[2], qlist[3])<br>
---------------------<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;|<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V &nbsp;V<br>
---- qArgEmprint() ----<br>
Target String..: Hi, I'm a pretty boy. Are you pretty girl?<br>
Result.........: Hi, I'm a pretty boy. Are you pretty girl?<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &nbsp;= &nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;===========<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;2 &nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>
Return: 5 (5 matches)<br>
-----------------------</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *query="I am a \"pretty girl\".", *qlist[MAX_TOKENS];
int queries;
queries = qArgMake(query, qlist);</xmp></td></tr>
</table>
<p><a name='qArgMatch()' href='#toc-qArgMatch()' class='plain'><b><font size='3'>qArgMatch()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qArgMatch(char *str, char **qlist);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Performs token-matching tests without distinguishing lowercase/uppercase letters.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns the number of tokens found in a specific character string.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Counts only once the same tokens even if they are matched repeatedly. Refer to the return value of qArgemprint() for the total matching counts in a character string including repeated matchings. Being divided into a hundred parts by the total number of the tokens acquired at qArgMake(), these values can be used for calculating the search accuracy.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int matches;
matches = qArgMatch("Hi, I'm a pretty boy. Are you pretty girl?", qlist);</xmp></td></tr>
</table>
<p><a name='qArgEmprint()' href='#toc-qArgEmprint()' class='plain'><b><font size='3'>qArgEmprint()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qArgEmprint(int mode, char *str, char **qlist);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Bold-prints the parts matched with tokens in a character string. This does not distinguish lowercase/uppercase letters.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns the number of tokens found in a character string. And unlike qArgMatch(), this returns all the matching counts including repeated matchings.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The mode value is same as that of qPrintf(). For a general purpose, 1 can be generally used.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qArgEmprint(1, "Hi, I'm a pretty boy. Are you pretty girl?", qlist);</xmp></td></tr>
</table>
<p><a name='qArgPrint()' href='#toc-qArgPrint()' class='plain'><b><font size='3'>qArgPrint()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qArgPrint(char **qlist);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays all the tokens interpreted for debugging programs.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qArgPrint(qlist);</xmp></td></tr>
</table>
<p><a name='qArgFree()' href='#toc-qArgFree()' class='plain'><b><font size='3'>qArgFree()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qArgFree(char **qlist);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Deallocates qlist which memory is allocated to.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qArgFree(qlist);</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qHttpHeader.c'>HTTP Response Functions</a></h3>
<p><a name='qContentType()' href='#toc-qContentType()' class='plain'><b><font size='3'>qContentType()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qContentType(char *mimetype);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Prints MimeType.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Executed only once even if it is called many times.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qContentType("text/html");  // when displaying HTML
qContentType("image/gif");  // when displaying the GIF image</xmp></td></tr>
</table>
<p><a name='qGetContentFlag()' href='#toc-qGetContentFlag()' class='plain'><b><font size='3'>qGetContentFlag()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qGetContentFlag(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Check execution of qContentType().</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>If qContentType() is executed before, returns 1. Or returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>if(qGetContentFlag() == 0) qCookieRemove("NAME", NULL, NULL, NULL);</xmp></td></tr>
</table>
<p><a name='qResetContentFlag()' href='#toc-qResetContentFlag()' class='plain'><b><font size='3'>qResetContentFlag()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qResetContentFlag(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Sets the internal flag of qContentType() to the initial status.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>qContentType() is executed only once even if it is called many times. When you need to forcibly display it again, call qContentType() after executing qResetContentFlag().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qContentType("text/html");
...some business logic here...

qResetContentFlag();
qContentType("text/html");
...some business logic here...

qResetContentFlag();
qContentType("text/html");
...some business logic here...</xmp></td></tr>
</table>
<p><a name='qRedirect()' href='#toc-qRedirect()' class='plain'><b><font size='3'>qRedirect()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qRedirect(char *url);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Jumps to a specific page using the Location: headers of HTTP.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Since qRedirect uses the HTTP headers, qConteneType() should be the only command that streams out in the corresponding process.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qRedirect("http://www.qdecoder.org/");</xmp></td></tr>
</table>
<p><a name='qJavaScript()' href='#toc-qJavaScript()' class='plain'><b><font size='3'>qJavaScript()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qJavaScript(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Print out some JavaScript code.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>It will print out below codes.<br>
<br>
&lt;script language=&quot;JavaScript&quot;&gt;<br>
YOUR CODES HERE<br>
&lt;/script&gt;</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qContentType("text/html");
qJavaScript("alert(\"hello\");");</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qEncode.c'>Encoding/decoding Functions</a></h3>
<p><a name='qURLencode()' href='#toc-qURLencode()' class='plain'><b><font size='3'>qURLencode()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qURLencode(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Encodes character strings in URL.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The character strings encoded in URL are returned with memory allocation. Deallocation(free) needs to be done by users.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>It does not encode '@', '.', '/', '\', '-', '_', ':' characters.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *encstr;
encstr = qURLencode("Hello!");</xmp></td></tr>
</table>
<p><a name='qURLdecode' href='#toc-qURLdecode' class='plain'><b><font size='3'>qURLdecode</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qURLdecode(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Decodes the character string that is URL-encoded into %xx.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Decoded string pointer.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>It stores decoded string into str directly.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *encstr;
qURLdecode(encstr);</xmp></td></tr>
</table>
<p><a name='qMD5Str()' href='#toc-qMD5Str()' class='plain'><b><font size='3'>qMD5Str()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qMD5Str(char *string);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Calculate a message-digest fingerprint (checksum) for a string.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>String pointer of 32 bytes fingerprint.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The return string pointer is declared as static inside the functions instead of being returned with memory allocation. This is to remove the inconvenience that users have to free() memory every tiem. Accordingly, it should be noted that the previous value is deleted whenever the functions are performed. And you should not modify or free() it directly.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>printf("Hash Result = %s", MD5Str("Hello"));

[Result]
Hash Result = 8b1a9953c4611296a827abf8c47804d7</xmp></td></tr>
</table>
<p><a name='qMD5File()' href='#toc-qMD5File()' class='plain'><b><font size='3'>qMD5File()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qMD5File(char *string);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Calculate a message-digest fingerprint (checksum) for a file.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>String pointer of 32 bytes fingerprint.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The return string pointer is declared as static inside the functions instead of being returned with memory allocation. This is to remove the inconvenience that users have to free() memory every tiem. Accordingly, it should be noted that the previous value is deleted whenever the functions are performed. And you should not modify or free() it directly.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>printf("Hash Result = %s", MD5File("qDecoder.tar.Z"));

[Result]
Hash Result = 499589b930e48996a64317c79e6cc36b</xmp></td></tr>
</table>
<p><a name='qFnv32Hash()' href='#toc-qFnv32Hash()' class='plain'><b><font size='3'>qFnv32Hash()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>unsigned int qFnv32Hash(char *str, unsigned int max);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qString.c'>String Handling Functions</a></h3>
<p><a name='qPrintf()' href='#toc-qPrintf()' class='plain'><b><font size='3'>qPrintf()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qPrintf(int mode, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Usage is same as that of printf(). Checks whether the HTML tag is applied and performs automatic links.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success - returns the number of displayed bytes. In case of failure, returns EOF.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The maximum size of the assembled strings should not exceed 10K(1024 * 10 - 1). <br>
<br>
Mode 00 : Same as printf()<br>
Mode 10 &nbsp;:Mode 0 + Convert<br>
<br>
Mode 01 : Print HTML TAG<br>
Mode 11 : Print HTML TAG + Convert<br>
<br>
Mode 02 : Print HTML TAG + Auto Link<br>
Mode 12 : Print HTML TAG + Auto Link + Convert<br>
<br>
Mode 03 : Print HTML TAG + Auto Link(_top)<br>
Mode 13 : Print HTML TAG + Auto Link(_top) + Convert<br>
Mode 23 : Print HTML TAG + Auto Link(new window)<br>
Mode 33 : Print HTML TAG + Auto Link(new window) + Convert<br>
<br>
Mode 04 : Waste HTML TAG<br>
Mode 14 : Waste HTML TAG + Convert<br>
<br>
Mode 05 : Waste HTML TAG + Auto Link<br>
Mode 15 : Waste HTML TAG + Auto Link + Convert<br>
<br>
Mode 06 : Waste HTML TAG + Auto Link(_top)<br>
Mode 16 : Waste HTML TAG + Auto Link(_top) + Convert<br>
Mode 26 : Waste HTML TAG + Auto Link(new window)<br>
Mode 36 : Waste HTML TAG + Auto Link(new window) + Convert<br>
<br>
Convert : &quot; &quot; &nbsp;&nbsp;-&gt; &quot; &quot;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; &nbsp;&quot; &nbsp;-&gt; &quot; &nbsp;&quot;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; &nbsp;&nbsp;&quot; -&gt; &quot; &nbsp;&nbsp;&quot;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot; &nbsp;&nbsp;-&gt; &quot;&lt;br&gt;\n&quot;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\r\n&quot; -&gt; &quot;&lt;br&gt;\n&quot;<br>
<br>
The Mode values of 10 and over can be efficiently used when successive<br>
blank is to be displayed on the screen without using the &lt;pre&gt; tag.<br>
In this case, the line change is automatically performed according to<br>
the changes of &nbsp;screen width.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qPrintf(i, "Mode %d: <font>\"http://www.qdecoder.org\"</font>\n", i);

Mode 0: <font>"http://www.qdecoder.org"</font>
Mode 1: <font>"http://www.qdecoder.org"</font>
Mode 2: <font>"<a href="http://www.qdecoder.org" target="">http://www.qdecoder.org</a>"</font>
Mode 3: <font>"<a href="http://www.qdecoder.org" target="_top">http://www.qdecoder.org</a>"</font>
Mode 4: "http://www.qdecoder.org"
Mode 5: "<a href="http://www.qdecoder.org" target="">http://www.qdecoder.org</a>"
Mode 6: "<a href="http://www.qdecoder.org" target="_top">http://www.qdecoder.org</a>"
Mode 10: <font>"http://www.qdecoder.org"</font><br>
Mode 11: <font>"http://www.qdecoder.org"</font><br>
Mode 12: <font>"<a href="http://www.qdecoder.org" target="">http://www.qdecoder.org</a>"</font><br>
Mode 13: <font>"<a href="http://www.qdecoder.org" target="_top">http://www.qdecoder.org</a>"</font><br>
Mode 14: "http://www.qdecoder.org"<br>
Mode 15: "<a href="http://www.qdecoder.org" target="">http://www.qdecoder.org</a>"<br>
Mode 16: "<a href="http://www.qdecoder.org" target="_top">http://www.qdecoder.org</a>"<br>

qPrintf(i, "Mode %d: ' ', '  ', '   ', '    '\n", i);

Mode 0: ' ', '  ', '   ', '    '
Mode 1: ' ', '  ', '   ', '    '
Mode 2: ' ', '  ', '   ', '    '
Mode 3: ' ', '  ', '   ', '    '
Mode 4: ' ', '  ', '   ', '    '
Mode 5: ' ', '  ', '   ', '    '
Mode 6: ' ', '  ', '   ', '    '
Mode 10: ' ', ' &nbsp;', ' &nbsp;&nbsp;', ' &nbsp;&nbsp;&nbsp;'<br>
Mode 11: ' ', ' &nbsp;', ' &nbsp;&nbsp;', ' &nbsp;&nbsp;&nbsp;'<br>
Mode 12: ' ', ' &nbsp;', ' &nbsp;&nbsp;', ' &nbsp;&nbsp;&nbsp;'<br>
Mode 13: ' ', ' &nbsp;', ' &nbsp;&nbsp;', ' &nbsp;&nbsp;&nbsp;'<br>
Mode 14: ' ', ' &nbsp;', ' &nbsp;&nbsp;', ' &nbsp;&nbsp;&nbsp;'<br>
Mode 15: ' ', ' &nbsp;', ' &nbsp;&nbsp;', ' &nbsp;&nbsp;&nbsp;'<br>
Mode 16: ' ', ' &nbsp;', ' &nbsp;&nbsp;', ' &nbsp;&nbsp;&nbsp;'<br></xmp></td></tr>
</table>
<p><a name='qPuts()' href='#toc-qPuts()' class='plain'><b><font size='3'>qPuts()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qPuts(int mode, char *buf);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Same as that of qPrintf() except that arguments cannot be transmitted by formats.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>since the given argument of buf is modified, constant character strings(ex: str = &quot;character string&quot;) or the variables that need to be used again should not be displayed in qPuts(). The reason why qPuts() exists is that there is no limitation to the length of argument strings unlike in qPrintf() and that the speed is a bit faster because the strdup() function is not used. <br>
<br>
The character strings transmitted to arguments are transformed. Accordingly if a constant character string like qPuts(mode, &quot;character string&quot;); is used, errors occur. In this case, copy the arguments as example.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char buf[100];
strcpy(buf, "http://www.qdecoder.org mailto:nobreak@hongik.com");
qPuts(2, buf);

char *buf;
buf = strdup("http://www.qdecoder.org mailto:nobreak@hongik.com");
qPuts(2, buf);
free(buf);</xmp></td></tr>
</table>
<p><a name='qRemoveSpace()' href='#toc-qRemoveSpace()' class='plain'><b><font size='3'>qRemoveSpace()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qRemoveSpace(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Removes white spaces(including CR, LF) before and after character strings.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the pointer of character strings. In case of failure, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>If this is used like qRemoveSpace(&quot;character string&quot;);, errors may occur. In this case, copy the arguments as example.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char teststr[100];
strcpy(teststr, "  Hello, world    \r\n  ");
qRemoveSpace(teststr); // After deletion, "Hello, world" is inserted in teststr.

char *teststr;
teststr = strdup("  Hello, world    \r\n  ");
qRemoveSpace(teststr); // After deletion, "Hello, world" is inserted in teststr.</xmp></td></tr>
</table>
<p><a name='qRemoveTailSpace' href='#toc-qRemoveTailSpace' class='plain'><b><font size='3'>qRemoveTailSpace</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qRemoveTailSpace(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qStrReplace()' href='#toc-qStrReplace()' class='plain'><b><font size='3'>qStrReplace()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qStrReplace(char *mode, char *srcstr, char *tokstr, char *word);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Transposes character strings and tokens for character strings.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Transposed string pointers.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The 'mode' argument is a character string consisting of two separate characters like &quot;sr&quot;. <br>
The first character defines the transposition method, and 't' or 's' can be located in its place. 't' stands for [t]oken. It compares the source character string of srcstr using each character of the tokstr character string as tokens and transposes matching characters into the word character strings. 's' stands for [s]tring. Using the tokstr string itself as the token, it transposes into the word character string the tokstr matching character strings appearing inside the source strings. <br>
<br>
The second character represents the record type of transposed character strings, and 'n' and 'r' can be used in its place. 'n' stands for [n]ew. It makes the corresponding pointers returned by storing the transposed result character strings in a new memory space. Accordingly, the source string should maintain its original state, and the corresponding memory should be free() from the user aspect. 'r' stands for [r]eplace and means overwriting the transposition results on srcstr. Here, srcstr is assumed to allow some leeway (it's not reallocatied for convenience sake). This should be noted when the [r]eplace mode is to be used. <br>
<br>
As a result, the 'mode' argument has 4 possible occasions of assembly as follows: <br>
<br>
 &nbsp;Mode &quot;tn&quot; : [t]oken transposition & stores results in a [n]ew space and returns<br>
 &nbsp;Mode &quot;tr&quot; : [t]oken transposition & [r]eplaces the string itself<br>
 &nbsp;Mode &quot;sn&quot; : [s]tring transposition & stores results in a [n]ew space and returns<br>
 &nbsp;Mode &quot;sr&quot; : [s]tring transposition & [r]eplaces the string itself</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Example)
  int  i;
  char srcstr[256], *retstr;
  char mode[4][2+1] = {"tn", "tr", "sn", "sr"};

  for(i = 0; i < 4; i++) {
    strcpy(srcstr, "Welcome to the qDecoder project.");
    printf("before %s : srcstr = %s\n", mode[i], srcstr);

    retstr = qStrReplace(mode[i], srcstr, "the", "_");
    printf("after  %s : srcstr = %s\n", mode[i], srcstr);
    printf("            retstr = %s\n\n", retstr);
    if(mode[i][1] == 'n') free(retstr);
  }

Result)
  before tn : srcstr = Welcome to the qDecoder project.
  after  tn : srcstr = Welcome to the qDecoder project.
              retstr = W_lcom_ _o ___ qD_cod_r proj_c_.

  before tr : srcstr = Welcome to the qDecoder project.
  after  tr : srcstr = W_lcom_ _o ___ qD_cod_r proj_c_.
              retstr = W_lcom_ _o ___ qD_cod_r proj_c_.

  before sn : srcstr = Welcome to the qDecoder project.
  after  sn : srcstr = Welcome to the qDecoder project.
              retstr = Welcome to _ qDecoder project.

  before sr : srcstr = Welcome to the qDecoder project.
  after  sr : srcstr = Welcome to _ qDecoder project.
              retstr = Welcome to _ qDecoder project.

Example 2) Convert to SQL String

  qStrReplace("sr", sqlvalue, "\\", "\\\\");
  qStrReplace("sr", sqlvalue, "'", "\\'");</xmp></td></tr>
</table>
<p><a name='qStr09AZaz()' href='#toc-qStr09AZaz()' class='plain'><b><font size='3'>qStr09AZaz()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qStr09AZaz(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Checks to see if character strings consist of 0-9, A-Z, a-z.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>If the condition is satisfied, return 1. If not, return 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>if(qStr09AZaz("abc1234") == 1) printf("True");</xmp></td></tr>
</table>
<p><a name='qStrupr()' href='#toc-qStrupr()' class='plain'><b><font size='3'>qStrupr()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qStrupr(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Converts into uppercase letters the character strings given in arguments.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The pointer of the pertinent characher string.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *str;
str = strdup("Hello World");
qStrupr(str);</xmp></td></tr>
</table>
<p><a name='qStrlwr()' href='#toc-qStrlwr()' class='plain'><b><font size='3'>qStrlwr()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qStrlwr(char *str);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Converts into lowercase letters the character strings given in arguments.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The pointer of the pertinent characher string.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *str;
str = strdup("Hello World");
qStrlwr(str);</xmp></td></tr>
</table>
<p><a name='qStristr()' href='#toc-qStristr()' class='plain'><b><font size='3'>qStristr()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qStristr(char *big, char *small);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Same as that of the strstr() function. But makes a comparison without distinguishing lowercase/uppercase letters.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as that of strstr().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>printf("%s", qStristr("Hello World", "WORLD"));</xmp></td></tr>
</table>
<p><a name='qStricmp()' href='#toc-qStricmp()' class='plain'><b><font size='3'>qStricmp()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qStricmp(char *s1, char *s2);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Same as that of the strcmp() function. But this does not distinguish lowercase/uppercase letters.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as that of strcmp().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>if(!qStricmp("Hello", "HELLO")) printf("Equal");
else printf("Differ");</xmp></td></tr>
</table>
<p><a name='qStrincmp()' href='#toc-qStrincmp()' class='plain'><b><font size='3'>qStrincmp()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qStrincmp(char *s1, char *s2, size_t len);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Same as that of the strncmp() function. But this does not distinguish lowercase/uppercase letters.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as that of strncmp().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>if(!qStrincmp("Hello World", "HELLO", 5)) printf("Equal");
else printf("Differ");</xmp></td></tr>
</table>
<p><a name='qitocomma()' href='#toc-qitocomma()' class='plain'><b><font size='3'>qitocomma()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qitocomma(int value);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Converts numeric characters into comma character strings.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The string pointer converted into characters.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The return string pointer is declared as static inside the functions instead of being returned with memory allocation. This is to remove the inconvenience that users have to free() memory every tiem. Accordingly, qitocomma() comes to return the same string pointer every time. And it should be noted that the previous value is deleted whenever the functions are performed.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>1) (O) example of right usage, when single arguments are used
   printf("Price = %s", qitocomma(1234567));
   Price = 1,234,567

2) (O) example of right usage, when plural arguments are used
   char a[14+1], b[14+1];
   strcpy(a, qitocomma(1234));
   strcpy(b, qitocomma(5678));
   printf("Price = %s + %s\n", a, b);
   Price = 1,234 + 5,678

3) (X) example of wrong usage
   printf("%s %s\n", qitocomma(1234), qitocomma(5678));
   Price = 1,234 + 1,234</xmp></td></tr>
</table>
<p><a name='qStrcat()' href='#toc-qStrcat()' class='plain'><b><font size='3'>qStrcat()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qStrcat(char str, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qStrdupBetween()' href='#toc-qStrdupBetween()' class='plain'><b><font size='3'>qStrdupBetween()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qStrdupBetween(char *str, char *start, char *end);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qFile.c'>File Handling Functions</a></h3>
<p><a name='qfopen()' href='#toc-qfopen()' class='plain'><b><font size='3'>qfopen()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>FILE *qfopen(char *path, char *mode);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Open file with file lock.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as fopen().</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>A file which is opened by qfopen() must be closed by qfclose().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>FILE *fp;

fp = qfopen("/tmp/report.txt", "w");
...
qfclose(fp);</xmp></td></tr>
</table>
<p><a name='qfclose()' href='#toc-qfclose()' class='plain'><b><font size='3'>qfclose()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qfclose(FILE *stream);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Close the file stream which is opened by qfopen().</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Same as fclose().</td></tr>
</table>
<p><a name='qCheckFile()' href='#toc-qCheckFile()' class='plain'><b><font size='3'>qCheckFile()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qCheckFile(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Identifies the existence of files.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>If files exist, return 1. If not, return 0.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>When files cannot be accessed due to &quot;permission&quot;, it judges that there is no file.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>if(qCheckFile("test.dat") == 0) qError("File not found");</xmp></td></tr>
</table>
<p><a name='qCatFile()' href='#toc-qCatFile()' class='plain'><b><font size='3'>qCatFile()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qCatFile(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays the contents of files.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In normal cases, the number of displayed characters. In case of errors, returns -1.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qContentType("image/gif");
qCatFile("mypic.gif");

qContentType("text/html");
qCatFile("myhtml.html");</xmp></td></tr>
</table>
<p><a name='qReadFile()' href='#toc-qReadFile()' class='plain'><b><font size='3'>qReadFile()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qReadFile(char *filename, int *size);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Returns pointers after it reads files and stores them in memory.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In normal cases, returns string pointers. In case of errors, returns NULL.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>When memory is allocated to qReadFile, additional 1 byte needs to be allocated (1 byte more than the actual file size) for string termination character '\0'. This is for easy-to-manage purpose by reading text files. The number of characters of files is stored in size. The NULL argument is transmitted to the size item when the number of characters is not needed.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *sp, *sp2;
int spsize;
sp  = qReadFile("filename", &spsize);
sp2 = qReadFile("filename2", NULL);
...
free(sp), free(sp2);</xmp></td></tr>
</table>
<p><a name='qSaveStr()' href='#toc-qSaveStr()' class='plain'><b><font size='3'>qSaveStr()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSaveStr(char *sp, int spsize, char *filename, char *mode);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Stores the contents of strings in the files.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In normal cases - the number of stored characters(file size). In case of errors, returns -1.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The mode argument is same as the mode value used in case of fopen. qSaveStr will open files via corresponding modes. File permission depends on the umask() settings value existing before calls.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *sp = "To subscribe qDecoder mailing list\nSend mail to majordomo@qdecoder.org";
int len;
umask(022);
len = qSaveStr(sp, strlen(sp), "howto-mailing.txt", "w");</xmp></td></tr>
</table>
<p><a name='qFileSize()' href='#toc-qFileSize()' class='plain'><b><font size='3'>qFileSize()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>long qFileSize(char *filename);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Returns the file size by the unit of byte.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the file size. No files, returns -1.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>long size;
size = qFileSize("/home/nobreak/sample.pdf");</xmp></td></tr>
</table>
<p><a name='qfGetLine()' href='#toc-qfGetLine()' class='plain'><b><font size='3'>qfGetLine()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qfGetLine(FILE *fp);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Reads lines of files without the length limitations.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Allocated memory pointers, end of file NULL.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Users need to deallocated the memory of the returned string pointer.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>line = qfGetLine(fp);</xmp></td></tr>
</table>
<p><a name='qfGets()' href='#toc-qfGets()' class='plain'><b><font size='3'>qfGets()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qfGets(FILE *fp);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qCmd()' href='#toc-qCmd()' class='plain'><b><font size='3'>qCmd()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qCmd(char *cmd);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qValid.c'>Validation Functions</a></h3>
<p><a name='qCheckEmail()' href='#toc-qCheckEmail()' class='plain'><b><font size='3'>qCheckEmail()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qCheckEmail(char *email);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Checks the validation of e-mail addresses.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>No errors, 1. Invalid email, 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qCheckEmail("nobreak@openbird.com");</xmp></td></tr>
</table>
<p><a name='qCheckURL()' href='#toc-qCheckURL()' class='plain'><b><font size='3'>qCheckURL()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qCheckURL(char *url);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Checks the errors of URL addresses.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>No errors, 1. If the addresses fail to meet rules, return 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qCheckURL("http://www.qdecoder.org/");</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qDownload.c'>Download Handling Functions</a></h3>
<p><a name='qDownload()' href='#toc-qDownload()' class='plain'><b><font size='3'>qDownload()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDownload(char *filename);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Transmits files to clients. Displays downloading boxes in browsers regardless of the kinds of files.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the number of transmitted bytes. If there is no file, returns -1.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>This function is a shell function of qDownloadMime() that is for convenience.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qDownload("/home/nobreak/myprg.exe");</xmp></td></tr>
</table>
<p><a name='qDownloadMime()' href='#toc-qDownloadMime()' class='plain'><b><font size='3'>qDownloadMime()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDownloadMime(char *filename, char *mime);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Transmits files to clients in accordance with MIME.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the number of transmitted bytes. If there is no file, returns -1.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The results of this function are the same as those acquired when the corresponding files are directly linked to the Web. But this is especially useful in preprocessing files to be downloaded only with user certification and in enabling downloading those files, which cannot be opned on the Web, only through specific programs. When MIME is 'application/octet-stream', it isthe same as qDownload(). And since processes are executed until streams are terminated, this is a file that can be linked on the Web. When it is to be used as preprocessing for the downloading count, it is better to utilize qRedirect().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qDownloadMime("/home/nobreak/myprg.gif", "image/gif");</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qCount.c'>Counter Handling Functions</a></h3>
<p><a name='qCountRead()' href='#toc-qCountRead()' class='plain'><b><font size='3'>qCountRead()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qCountRead(char *filename);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Reads counter file.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the counter value. In case of failure, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Handles the following types of counter files. <br>
<br>
---- number.dat ----<br>
74<br>
--------------------</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int count;
count = qCountRead("number.dat");</xmp></td></tr>
</table>
<p><a name='qCountSave()' href='#toc-qCountSave()' class='plain'><b><font size='3'>qCountSave()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qCountSave(char *filename, int number);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Stores(updates) the counter value in the specified file name.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns 1. In case of failure, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qCountSave("number.dat", 75);</xmp></td></tr>
</table>
<p><a name='qCountUpdate()' href='#toc-qCountUpdate()' class='plain'><b><font size='3'>qCountUpdate()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qCountUpdate(char *filename, int number);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Increases the counter value of specified file names as much as number.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>In case of success, returns the updated counter value. In case of failure, returns 0.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int count;
count = qCountUpdate("number.dat", -3);</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qEnv.c'>Environment Related Functions</a></h3>
<p><a name='qCGIenv()' href='#toc-qCGIenv()' class='plain'><b><font size='3'>qCGIenv()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qCGIenv(Q_CGIenv *env);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Stores the environment variable of CGI and time in the structure.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>Q_CGIenv myenv;
qCGIenv(&myenv);

/* Q_CGIenv Data Structure */
typedef struct Q_CGIenv Q_CGIenv;
struct Q_CGIenv{
  char *auth_type;
  char *content_length;
  char *content_type;
  char *document_root;
  char *gateway_interface;
  char *http_accept;
  char *http_accept_encoding;
  char *http_accept_language;
  char *http_connection;
  char *http_cookie;
  char *http_host;
  char *http_referer;
  char *http_user_agent;
  char *query_string;
  char *remote_addr;
  char *remote_host;
  char *remote_port;
  char *remote_user;
  char *request_method;
  char *request_uri;
  char *script_filename;
  char *script_name;
  char *server_admin;
  char *server_name;
  char *server_port;
  char *server_protocol;
  char *server_software;
  char *server_signature;
  char *unique_id;

  /* Miscellaneous Informations Supported by qDecoder */
  int  year, mon, day, hour, min, sec;
};</xmp></td></tr>
</table>
<p><a name='qCGIname()' href='#toc-qCGIname()' class='plain'><b><font size='3'>qCGIname()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qCGIname(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Interprets only the program names at the environment variable of SCRIPT_NAME and returns.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The string pointer containing CGI name.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *cginame;
cginame = qCGIname();</xmp></td></tr>
</table>
<p><a name='qGetenvDefault()' href='#toc-qGetenvDefault()' class='plain'><b><font size='3'>qGetenvDefault()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>qGetenvDefault(char *nullstr, char *envname);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Operates the same as the getenv() function. But returns default strings instead of NULL.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *name;
name = qGetenvDefault("/cgi-bin/CrazyWWWBoard.cgi", "SCRIPT_NAME");
name = qGetenvDefault(NULL, "SCRIPT_NAME");</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qTime.c'>Time Functions</a></h3>
<p><a name='qGetTime()' href='#toc-qGetTime()' class='plain'><b><font size='3'>qGetTime()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>struct tm *qGetTime(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Stores time in the tm structure.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The pointer of the tm structure.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>struct tm *mytime;
mytime = qGetTime();</xmp></td></tr>
</table>
<p><a name='qGetGMTime()' href='#toc-qGetGMTime()' class='plain'><b><font size='3'>qGetGMTime()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>time_t qGetGMTime(char *gmt, time_t plus_sec);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Converts present time+plus_sec into the GMT character-string time that is used in cookies.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The seconds from 1970/1/1(00:00:00) to the present + plus_sec.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>time_t plus_sec;
char gmt[32];
plus_sec = (time_t)300; /* 5min */
qGetGMTime(gmt, plus_sec);
printf("%s", gmt); // "Fri, 22-Aug-1997 15:11:30 GMT"</xmp></td></tr>
</table>
<p><a name='qGetTimeStr()' href='#toc-qGetTimeStr()' class='plain'><b><font size='3'>qGetTimeStr()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qGetTimeStr(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>returns the string formatted by YYYYMMDDhhmmss.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>The pointer of the internal static string.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *timestr;
timestr = qGetTimeStr();</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qSocket.c'>Socket Handling Functions</a></h3>
<p><a name='qSocketOpen()' href='#toc-qSocketOpen()' class='plain'><b><font size='3'>qSocketOpen()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketOpen(char *hostname, int port);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Create a TCP socket for communication.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>returns socket descriptor(positive). In case of invalid hostname, returns -1 and in case of socket creation fail, returns -2.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int sockfd;

sockfd = qSocketOpen("www.qdecoder.org", 80);</xmp></td></tr>
</table>
<p><a name='qSocketClose()' href='#toc-qSocketClose()' class='plain'><b><font size='3'>qSocketClose()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketClose(int sockfd);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Close the socket.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>returns the value 0 if successful, otherwise returns the value -1.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSocketClose(sockfd)</xmp></td></tr>
</table>
<p><a name='qSocketWaitReadable()' href='#toc-qSocketWaitReadable()' class='plain'><b><font size='3'>qSocketWaitReadable()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketWaitReadable(int sockfd, int timeoutsec);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Block the program until the socket has readable data.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>returns the value 1 when it is readable, otherwise(such as timeout) the value of 0 is returned.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>You don't need to set the socket as non-block mode. This is magic of qDecoder ^^;</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>int sockstatus;
sockstatus = qSocketWaitReadable(sockfd, 10);
if(sockstatus != 1) qError("Timeout!");</xmp></td></tr>
</table>
<p><a name='qSocketRead()' href='#toc-qSocketRead()' class='plain'><b><font size='3'>qSocketRead()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketRead(char *binary, int size, int sockfd, int timeoutsec);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Reads socket stream.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns the length of data readed. otherwise(timeout) the value -1 is returned.</td></tr>
</table>
<p><a name='qSocketGets()' href='#toc-qSocketGets()' class='plain'><b><font size='3'>qSocketGets()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qSocketGets(char *str, int size, int sockfd, int timeoutsec);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Read line from the stream. it does not contain the character CR and LF.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>returns the length of data readed from stream. In case of timeout, returns 0 and in case of error(EOF) returns -1</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The return value is not differ from the length of str, because it is actual bytes readed from stream, it also counts CR, LF. But we do not store CR, LF into str, so you do not use the return value to calculate the length of str. If you need to know the size stored in str, please use strlen(str);</td></tr>
</table>
<p><a name='qSocketWrite()' href='#toc-qSocketWrite()' class='plain'><b><font size='3'>qSocketWrite()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketWrite(char *binary, int size, int sockfd);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Send some data(text/binary) to socket stream .</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns the number of bytes sent if successful, otherwise the value -1 is returned.</td></tr>
</table>
<p><a name='qSocketPuts()' href='#toc-qSocketPuts()' class='plain'><b><font size='3'>qSocketPuts()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketPuts(char *str, int sockfd);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Send one line with terminating newline character to socket stream.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns the value 1 if successful, otherwise the value 0 is returned.</td></tr>
</table>
<p><a name='qSocketPrintf()' href='#toc-qSocketPrintf()' class='plain'><b><font size='3'>qSocketPrintf()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketPrintf(int sockfd, char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Send formatted data to socket stream.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns the value 1 if successful, otherwise(connection closed by foreign host?) the value 0 is returned.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The final length of formatted data must be less than 1024-1.<br>
If you need to send more data, use qSocketPuts instead.</td></tr>
</table>
<p><a name='qSocketSendFile()' href='#toc-qSocketSendFile()' class='plain'><b><font size='3'>qSocketSendFile()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketSendFile(char *filepath, int offset, int sockfd);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Send file data to socket stream.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns total sent bytes, otherwise the value -1 returned.</td></tr>
</table>
<p><a name='qSocketSaveIntoFile()' href='#toc-qSocketSaveIntoFile()' class='plain'><b><font size='3'>qSocketSaveIntoFile()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketSaveIntoFile(int sockfd, int size, int timeoutsec, char *filepath, char *mode);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Save stream data into file directly.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns total read bytes otherwise(timeout) the value -1 is returned.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qSocketSaveIntoFile(sockfd, reading_length, 10, "/home/savedata/pic.jpg", "w");</xmp></td></tr>
</table>
<p><a name='qSocketSetNonblock()' href='#toc-qSocketSetNonblock()' class='plain'><b><font size='3'>qSocketSetNonblock()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qSocketSetNonblock(int sockfd);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Set the socket to non-blocking mode.</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>returns the value 1 if successful, otherwise the value 0 is returned.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>We support this function for compatible resons. But we think you do not need this function to handle non-blocked socket because qDecoder's other functions supports non-blocking handles inside.<br>
<br>
DO NOT USE this function untile you surely know what it means. Please use qSocketWaitReadable() instead.</td></tr>
</table>
<p><a name='qSocketConv2file()' href='#toc-qSocketConv2file()' class='plain'><b><font size='3'>qSocketConv2file()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>FILE *qSocketConv2file(int sockfd);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Convert the socket descriptor(int type) to file descriptor(FILE type).</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>Returns the pointer of converted file descriptor.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>So you can use the stream easily by using fprintf(), fscanf()...<br>
But qDecoder supports all same functions, so you do not convert socket descriptor into file descriptor for convenience reasons.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>FILE *sockfp;

sockfp = qSocketConv2file(sockfd);
fprintf(sockfp, "Hello");</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qDatabase.c'>Database Independent Wrapper Functions</a></h3>
<p><a name='qDbInit()' href='#toc-qDbInit()' class='plain'><b><font size='3'>qDbInit()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_DB *qDbInit(char *dbtype, char *addr, int port, char *username, char *password, char *database, int autocommit);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbOpen()' href='#toc-qDbOpen()' class='plain'><b><font size='3'>qDbOpen()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbOpen(Q_DB *db);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbClose()' href='#toc-qDbClose()' class='plain'><b><font size='3'>qDbClose()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbClose(Q_DB *db);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetErrMsg()' href='#toc-qDbGetErrMsg()' class='plain'><b><font size='3'>qDbGetErrMsg()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qDbGetErrMsg(Q_DB *db);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbPing()' href='#toc-qDbPing()' class='plain'><b><font size='3'>qDbPing()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbPing(Q_DB *db)</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetLastConnStatus()' href='#toc-qDbGetLastConnStatus()' class='plain'><b><font size='3'>qDbGetLastConnStatus()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbGetLastConnStatus(Q_DB *db);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbExecuteUpdate()' href='#toc-qDbExecuteUpdate()' class='plain'><b><font size='3'>qDbExecuteUpdate()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbExecuteUpdate(Q_DB *db, char *pszQuery);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbExecuteQuery()' href='#toc-qDbExecuteQuery()' class='plain'><b><font size='3'>qDbExecuteQuery()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_DBRESULT *qDbExecuteQuery(Q_DB *db, char *pszQuery);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetRows()' href='#toc-qDbGetRows()' class='plain'><b><font size='3'>qDbGetRows()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbGetRows(Q_DBRESULT *result);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetCols()' href='#toc-qDbGetCols()' class='plain'><b><font size='3'>qDbGetCols()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbGetCols(Q_DBRESULT *result);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbResultNext()' href='#toc-qDbResultNext()' class='plain'><b><font size='3'>qDbResultNext()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbResultNext(Q_DBRESULT *result);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbResultFree()' href='#toc-qDbResultFree()' class='plain'><b><font size='3'>qDbResultFree()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbResultFree(Q_DBRESULT *result);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetValue()' href='#toc-qDbGetValue()' class='plain'><b><font size='3'>qDbGetValue()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qDbGetValue(Q_DBRESULT *result, char *field);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetInt()' href='#toc-qDbGetInt()' class='plain'><b><font size='3'>qDbGetInt()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbGetInt(Q_DBRESULT *result, char *field);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetValueAt()' href='#toc-qDbGetValueAt()' class='plain'><b><font size='3'>qDbGetValueAt()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qDbGetValueAt(Q_DBRESULT *result, int idx);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbGetIntAt()' href='#toc-qDbGetIntAt()' class='plain'><b><font size='3'>qDbGetIntAt()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbGetIntAt(Q_DBRESULT *result, int idx);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbBeginTran()' href='#toc-qDbBeginTran()' class='plain'><b><font size='3'>qDbBeginTran()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbBeginTran(Q_DB *db);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbEndTran()' href='#toc-qDbEndTran()' class='plain'><b><font size='3'>qDbEndTran()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbEndTran(Q_DB *db, int nCommit);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbCommit()' href='#toc-qDbCommit()' class='plain'><b><font size='3'>qDbCommit()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbCommit(Q_DB *db);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qDbRollback()' href='#toc-qDbRollback()' class='plain'><b><font size='3'>qDbRollback()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qDbRollback(Q_DB *db);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qLog.c'>Log Handling Functions</a></h3>
<p><a name='qLogOpen()' href='#toc-qLogOpen()' class='plain'><b><font size='3'>qLogOpen()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>Q_LOG *qLogOpen(char *pszLogBase, char *pszFilenameFormat, int nRotateInterval, int nFlushFlag);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qLogClose()' href='#toc-qLogClose()' class='plain'><b><font size='3'>qLogClose()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qLogClose(Q_LOG *log);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qLogSetConsole()' href='#toc-qLogSetConsole()' class='plain'><b><font size='3'>qLogSetConsole()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qLogSetConsole(Q_LOG *log, int nFlag);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qLogFlush()' href='#toc-qLogFlush()' class='plain'><b><font size='3'>qLogFlush()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qLogFlush(Q_LOG *log);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>
<p><a name='qLog()' href='#toc-qLog()' class='plain'><b><font size='3'>qLog()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>int qLog(Q_LOG *log, char *pszFormat, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>This function will be released at 8.1R</td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qError.c'>Error Handling Functions</a></h3>
<p><a name='qError()' href='#toc-qError()' class='plain'><b><font size='3'>qError()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qError(char *format, ...);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Displays the messages for errors. Usage is same as that of the printf() function.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The maximum size of the assembled error message should not exceed 1023(1024-1) byte.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qError("error message");
qError("errors at %s", buf);</xmp></td></tr>
</table>
<p><a name='qErrorContact()' href='#toc-qErrorContact()' class='plain'><b><font size='3'>qErrorContact()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qErrorContact(char *msg);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>As the footer of error messages, always displayed together when qError() is called. This is generally used to provide fixed information such as producers.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qErrorContact("- qDecoder Project.");
qErrorContact(NULL);            // disable (default)</xmp></td></tr>
</table>
<p><a name='qErrorLog()' href='#toc-qErrorLog()' class='plain'><b><font size='3'>qErrorLog()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qErrorLog(char *file);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Sets up the log files on which the error messages--which are transmitted when the qError() function is called--are recorded.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>When logs are recorded, the main file is not directly called. Like qErrorLog(&quot;logs/error.log&quot;), once it is called at the initial period of programs, logs are automatically recorded in the 'logs/error.log' file whenever qError() is called afterwards.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qErrorLog("/tmp/error.log");    // enable log
qErrorLog(NULL);                // disable log (default)</xmp></td></tr>
</table>

<hr size='1' noshade>
<p><h3><a name='qMisc.c'>Miscellaneous Functions</a></h3>
<p><a name='qFreeAll()' href='#toc-qFreeAll()' class='plain'><b><font size='3'>qFreeAll()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qFreeAll(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Deallocates the all allocated memories by qDecoder.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>Internally, qFreeAll() calls qFree(), qSessionFree(). You can use qFreeAll() instead qFree() and qSessionFree() at the end of program to deallocate all allocated memories by qDecoder.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>qDecoder();
qSession(NULL);
...
...
...
qFreeAll();</xmp></td></tr>
</table>
<p><a name='qReset()' href='#toc-qReset()' class='plain'><b><font size='3'>qReset()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>void qReset(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Deallocates the all allocated memories and Initialize qDecoder.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>When you wish to make a daemon-type repetitive program or to initialize qDecoder anew, you can use this function. qReset() returns all the allocated memory including the linked-list and restores internal static variables to the initial condition. You do not need to call qFreeAll() when you use qReset().</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>while(1) {
  qDecoder();
  qSession(NULL);
  ...
  ...
  ...
  qReset();
}</xmp></td></tr>
</table>
<p><a name='qUniqueID()' href='#toc-qUniqueID()' class='plain'><b><font size='3'>qUniqueID()</font></b></a>
<p><table border='0'>
<tr><td width='80' align='right' valign='top'><b>Syntax:</b></td><td>char *qUniqueID(void);</td></tr>
<tr><td align='right' valign='top'><b>Function:</b></td><td>Always returns unique 32 bytes string .</td></tr>
<tr><td align='right' valign='top'><b>Return:</b></td><td>String pointer of 32 bytes unique string.</td></tr>
<tr><td align='right' valign='top'><b>Note:</b></td><td>The return string pointer is declared as static inside the functions instead of being returned with memory allocation. This is to remove the inconvenience that users have to free() memory every tiem. Accordingly, it should be noted that the previous value is deleted whenever the functions are performed. And you should not modify or free() it directly.</td></tr>
<tr><td align='right' valign='top'><b>Example:</b></td><td><xmp>char *uniqueid;

uniqueid = qUniqueID();</xmp></td></tr>
</table>
<center>
<hr width="100%" noshade>

<table border="0"><tr><td>
<a href="http://www.qDecoder.org/">[Home]</a>
<a href="/about.qsp">[About]</a>
<a href="/releases/lastest/examples/">[Examples]</a>
<a href="/changes.qsp">[Changes]</a>
<a href="/download.qsp">[Download]</a>
<a href="/install.qsp">[Install]</a>
<a href="/reference/">[Reference]</a>
<a href="/devreq.qsp">[Development Request]</a>
<a href="/apps/bbs.cgi?db=qdecoder">[Q&A]</a>
</td></tr></table>

<br>Powered by <a href="http://www.kr.freebsd.org/~nobreak/" target="myhome">Seung-young Kim.</a>
Last updated at Nov 12, 2004.

</center>
</body>
</html>

