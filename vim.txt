vimrc
----------------------------------------------------------------------
vim -u NONE
vim -u ~/vimrc-alternate        alternate vimrc
:source $MYVIMRC                reload vimrc file

modeline
special line at the begining and end of file with vim options for that file


Get Info
----------------------------------------------------------------------
:set runtimepath?    what is my runtime path
:version             what vimrc files are loaded
vim -u {vimrc}       load specific vimrc file
vim -u NONE          Dont load any vimrc file


Multiple files
-----------------------
:e file2
Ctrl-^           toggle between files (also :e#)
:n               next file (when started as: vim file1 file2)

:tabe file.txt   (open new tab)
:tabn :tabp      (next prev tab)
gt gT            (next prev tab)

:ls              (list of current buffers)
:b2              (go to numbered buffer, given by ls command)
:bn :bp          (buffer next prev)
:bd3             (delete/close buffer number #)
:bp|bd#          close buffer without closing the window

:qall            (close all files)

:e %<.h          open corresponding header file
:e %<.c          open corresponding source file
:e!              discard all changes to current buffer.


" -------------------------------------------------------------
"                           searching
" ------------------------------------------------------------
:h whitespace            "reference on character classes

*        "search the string under cursor
#        "search the string under cursor backwards
[I       "Show all lines containing word under cursor

case
\c<pattern>  ignore case
\C<pattern>  Case sensitive
i            ignore case :s/foo/bar/gi


Don't escape in regular expression
[ and ]     range
*           star quantifier
&           the whole matched pattern

Escape in regular expression
\?
\( and \)
\+

:h ordinary-atom
/the\>                  words ending in 'the'
/\<the\>                search for the word 'the' exactly
/\%>9l\%<21lgreen       Search in lines 10 to 20 inclusive
/\%>'a\%<'bgreen        Search between marks a and b
/^"INVITE\_.\{-}Cont    Search for INVITE at begining of line followed by Cont somewhere in text
\{-}                    0 or more but as few as possible.
\_.                     any char or end-of-line :h ordinay-atom
\=                      zero or one occurance of previous atom
/^\w\+\ze(/j            Search for functions
:s/CTRL-v CTRL-m//g     search and replace new lines (windows)"
:s/\(^\s\+\)/\1\/\//    comment out lines (comment characters placed after the initial space)

:set nows               will not search past the top or bottom.
:set hls                Highlight search pattern
:noh                    No highlight search pattern

:vimgrep term *.c* *.h         "grep in current directory (:pwd)
:vimgrep term **/*.c* **/*.h   "grep in current and sub-directories
:vimgrep 'pattern' %:p:h/*     "grep in directory of current file
:!grep 'pattern' %:p:h/*       "grep in directory of current file


s/\d\+/\=submatch(0) + 1/      Alter sequence number in a numbered list
\d\+                           search a digit sequence
\=submatch(0) + 1              get the matched pattern and add 1 to it.
\=line('.')%10
:s@\d@\=line('.')%10@          divide is a little complicated
\=submatch(0) + 1              get the matched pattern and add 1 to it.
\=<expression>                 Replace with the result of the expression
:s/pat/\=expand("%:p")/        The expression can be quiet complex for example:
                                  \="\n  " . substitute(submatch(1), "}", "\n}", "")/g
                                  \=@a  - replace with content of register 'a'
\_s                            "space including new line


:.,$ g/FINDME/p                "search from cursor to end of file
:'<,'>s/\%Vabc/efg/            "search and replace in visual selection

/\%V
search inside the visually selected area :'<,'>s/\%V(/#/g



" ---- multiple files search ----

:bufdo %s/pattern/replace/ge | update  "Search and Replace in all open buffers
:windo %s/pattern/replace/ge           "Search and Replace in all windows


:argsdelete *                          clear args list
:bufdo :argadd %                       Populate args list, same as ':args ## %'
:args                                  check args list
:bufdo :vimgrep /blah/ ##              search in all files in args list


" Search and replace in all files in arglist.
:arg *.cpp      " All *.cpp files in current directory (:pwd)
:argadd *.h     " And all *.h files.
:arg            " Optional: Display the current arglist.
:argdo %s/pattern/replace/ge | update

:arg **/*.cpp   " All *.cpp files in and below current directory (:pwd)
:argadd **/*.h  " And all *.h files.




# Fast cursor movement
# -------------------
H     # top of screen
M     # middle of screen
L     # bottom of screen

89G   # Go to line 89
30|   # Jump to column 30
`.    # move to last edit position

^E - scroll the view-port down
^Y - scroll the view-port up
^F - scroll down one page
^B - scroll one page up

Fast text Movement
------------------
zt or zENTER: make the line with the cursor the top line of the screen.
zz or z.    : center
zb or z-    : bottom
zs and ze   : move document like the hand tool in acrobat zs moves rigth
              and ze moves left
zh and zl   : scroll right,left by character
zH and zL   : scroll right, left by half a screen
Note        : use g^ and g$ instead of ^ and $ when the document is scrolled




Matching Bracket
-----------------
%



Auto Completion
--------------

Ctrl-p         : complete from previous words: search backwards
Ctrl-n         : complete from following words: search forwards
Ctrl x  Ctrl f : complete filename.
Ctrl x  Ctrl ] : similar to Ctrl n  and Ctrl p but completes only tags.
Ctrl x  Ctrl l : complete entire line. Context aware, gets next line when
                 pressed again.
Ctrl x  Ctrl o : Programming language specific completion.


:set dictionary=file
Ctrl-x  Ctrl-k : enter dictionary completion mode


Indent
-----
== adjust indent
=G adjust indent to the end of file


Diff
-----
]c [c                " next change, previous change
dp                   " put Block
do                   " get Block
:diffupdate
:[range]diffget
:[range]diffput
:w !diff %           " diff with saved version

:e main.c            " diff current file to another file
:vert diffsplit main.c~

:e main.c            " diff current file to its patched file
:vert diffpatch main.c.patch

:set noscrollbind    " Tmp turn off scroll bind
:diffthis            " Make the current window part of the diff windows.
:diffoff             " turn off diff mode
:diffoff!            " switch off diff in all windows
Ctrl w =             " make windows same size
Ctrl w |             " make windows maximum size


Manually delete multiple lines
-----------------------------
dd
. (press dot)
. (press dot again)

di)
    delete everything between parenthesis
di}
    delete everything between curly brackets
d/regex
    delete until regex match
:g/pattern/d
    delete all line matching pattern


Source code
--------------
gd : find local declaration
gD : find global declaration
gf : file under cursor, Ctrl-O to come back.
#include "f CTRL−x CTRL−f"
:set dictionary=file
Ctrl-x Ctrl-k : complete from dictionary
[[      go to start of function     previous '{' in the first column
][      go to end of function       next '}' in the first column
:help 29.3

[{ jump back to "{" at the start of current block
gd jump from use of variable to its local declaration.






switch esc and caps lock
------------------------
- create .Xmodmap
  keycode 9=Caps_Lock
  keycode 66=Escape



marks
---------
  mx   tells Vim to add a mark called x.
  `x return to the line and column for mark x.
  'x return to the beginning of the line where mark x is set.

  [     first character of changed / yanked / inserted text
  ]     last character of changed / yanked / inserted text
  <     start of last visual selection
  >     end of last visual selection
  '     position before last jump
  "     where last exited
  ^     where last insert was stopped
  .     where last change was made

  :marks shows all marks set.
  :marks x shows the mark named x.

  :jumps shows the jumplist.
  Ctrl-o moves the cursor to the last jump.
  Ctrl-i moves the cursor to the previous jump.


  Examples:
  -----------
  :'g,'k d
    delete lines between mark g and k

  :'s,. w ~/tmp/file.txt
    write text between mark s and current cursor position to ~/tmp/file.txt


visual selection
----------------
v       selection mode
V       select by line
Ctrl V  block select
gv      select previous visual area


show hidden symbols
-------------------
:set list
:set nolist



Folds
----------------------
:set foldmethod=indent
' then use zm and zr

zo    open one fold level under cursor
zc    close one fold level under cursor

zr    reduce folding by one level (open one more level)
zm    fold more by one level

zR    open all folds  (R for Reduce)
zM    close all folds

za    Toggle fold 


:set foldmethod=marker
' then enter /* some text {{{ */ at the begining
' enter /* }}}*/ at the end
' go in the block and zm

:set foldmethod=manual
    then go inside a {} block zfa}        zf = create fold operater, a} = text object
    visual select and zf


:help usr_28
:help options




Visible screen actions
----------------------
dL - Delete to end of page, in other words, everything visible.



tricks
------
imap <M-f> <E
visual mode selection followed by !sort is really useful for sorting lines
C - Often overlooked: chop off end of line and go into insert mode.
c/"[enter] Great for modifying things in quotes:
Much easier is to use :a! (or :i!), paste your text and then end the paste
    with a line containing just .
gF: Open the file under the cursor,

(ctrl-v) -> visually select a column
(shift-i) -> go to insert mode
(your favorite character here - I like #)
esc, esc

Ctrl-A and Ctrl-X [vim.org] find the next number on the line starting at the
cursor, and then increment or decrement it respectively.




2. Ctrl-P and Ctrl-N for very smart auto-completion can save another 30-50% of
your time.

3.  recording command sequence
qc  record typed character in register c
q   stop recording
@c  execute the contents of c
@@  repeat previous @ command


Or right in VIM - :E - would list files in :pwd.

:sh works well when you don't know root, but have sudo privs.



g
----------------------------------------------------------------------
gi — Move to the last insert you did and enter Insert mode.
gv — Start visual mode and use the previous selection made.
gI — Start inserting at the beginning of the line

These make it so when a line has wrapped, jk navigation moves one line on the
screen, instead of one line in the file
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

visuals
----------------------------------------------------------------------
this gives you a current-row and current-column highlight, so you never lose
your cursor
set cursorcolumn
set cursorline
hi cursorcolumn ctermbg=red


help
----------------------------------------------------------------------
To view man page of a word under curser, type K(shift+K)


Alternative Esc
--------------------
Ctrl-C instead of Esc for switching from insert mode into command mode
Ctrl-[, which does exactly the same as Escape, and Ctrl-C




Tags
--------------------

- generate tags
    cd src/
    ctags -R            (Recursive)
    ctags *             (all files in this dir)
    ctags . ../libewn   (multiple directories)
    :!ctags -R *.c *.h  (from within vi)

- set tag files
    :set tags=./tags,tags./home/aawais/commontags

    Ctrl-] on any function name, structure name/field, etc. to jump to the declaration point
    Ctrl-T to come back
    Ctrl-], Ctrl-T  Auto completion for the tag name
    :ta   jump to tag



Editing binary files
--------------------

# open and edit
vi -b file.bin
:%!xxd                # view in hex format
:set display=uhex     # show unprintable chars as hex <xx>
:set rulerformat=0x%B # show hex value of character under cursor in ruler
:set statusline+=%o   # Add byteoffset to status line
:goto 2356            # jump to nth byte

# save
:!%xxd -r             # revert to normal view (must do before saving)
:set binary
:wq


# other hex editors
bvi
bless


# ----------------------------------
# Syntax files and color schemes
# ----------------------------------
custom syntax files location. If the directory does not exist,
create it and put your custom syntax file there
    ~/.vim/syntax/mlg.vim
    ~/.vim/syntax/panlog.vim

vim syntax files location
    /usr/share/vim/vim73/syntax

using custom syntax file in vim:
  :set syntax=panlog

common commands in syntax files:
  :syntax keyword <group-name> word1 word2 word3 ...
  :syntax match  <group-name> 'pattern'
  :highlight def link <my-group> <built-in-group>

colorschemes are stored in:
  ~/.vim/colors  OR $VIMRUNTIME/colors  (:echo $VIMRUNTIME)

what is my current color scheme
  :colorscheme <enter>
see all color schemes
  :colorscheme <space><tab>  [press Ctrl-d to exit]
change colorscheme
  colorscheme aawais

highlight some colums, example: highlight Columns 13 and 80 with hl-ColorColumn
  set colorColumn=13,80

change color of numbers column
  :highlight LineNr ctermbg=0

Good colorscheme for diff
1. morning



windows (^ means Ctrl )
-------
^Ws: horizontal split
^Wn: horizontal split with new file
^Wv: vertical split
^ww: changes between the panes.
^w+: increase height by 1
^w-: decrease height by 1
^W>: increase width by 1
^W<: decrease width by 1
^w=: makes all panes the same size.
^W<direction_key>: to move between windows; direction key relative horizontal or vertical split
^Wx: swap windows
^W_: Maximize height
^W+: restore after ^W_

:on[ly]                 fill screen with current buffer.
:sp [filename]          opens the file in a new horizontal pane.
:vs [filename]          opens the file in a new vertical pane.
:vs | b <buffer name>   open named buffer in vertical split
:vert sb 5              open buffer 5 in a vertical split (:vs #5) (sb = split and open buffer)



edit-compile-edit cycle, (coding, development)
----------------------------------------------------------------------
Using quickfix commands
    cope:           open errors window (means: copen or cw)
    ccl:            close errors window

    <Enter>:        Jump to error
    Ctrl-<Enter>:   Open a new window and jump to error there

    cn             # Next error
    cp             # Previous error
    cl             # See all errors
    cc             # See full error text
    cc [nr]        # Jump to [nr]
    cr             # Jump to first error (rewind)
    clas           # Jump to last error




copy to X11 clipboard
------------------------
- On linux there are two system clipboards '*' and '+'. On windows and MacOSX the are both the same '*'
- Vim must be compiled with "+clipboard". Check with :echo has('clipboard')

"*yy:   copy to X11 mouse select clipboard so that it can pasted with middle mouse button
"*p:    paste text form X11 mouse select clipboard.

"+yy:   copy to copy/paste (ctrl-c/ctrl-v) clipboard
"+p:    paste from X11 copy/paste clipboard

To make clipboard work through ssh:
ssh -Y aawais@terbium

To get a vim version with +clipboard install
ubuntu: vim-gtk3
fedora: vim-X11 and then run vimx instead of vim

To make vim automatically copy to '+' and '*' clipboards
set clipboard=unnamedplus
set clipboard+=unnamed

To use xclip if +clipboard is not available
:'<,'>w !xclip                  # Linux
:'<,'>w !pbcopy                 # MacOsx

:help quotestar


spelling
---------
:set spell spelling=en_us
:set nospell
]s next misspelled
[s previous
z= suggestions
zg add word to dictionary


Using vim instead of more or less (read from stdin)
---------------------------------------------------
cvs log Interface.cpp | vim -R -


# Quick changes
find the word with *
change it with cw
find next occurence *
repeat the change . (dot)


# Macro
qa start recording in register 'a'.
q end recording
@a repeat recorded commands


# Quick Jumps
[{ jump back to "{" at the start of current block
gd jump from use of variable to its local declaration.


# Encrypted file
:X
:set viminfo=
:set local cm=blowfish


# installing plugin in vim for bundle
cd ./vim/bundle
curl 'www.vim.org/scripts/download_script.php?src_id=21351' > counterpoint.zip
unzip -d counterpoint counterpoint.zip



# ----------------------------------------------------------------------------
#                             installing lightline
# ----------------------------------------------------------------------------
# 1. install lightline
git clone https://github.com/itchyny/lightline.vim ~/.vim/bundle/lightline.vim

# 2. get fontpatcher
git clone https://github.com/Lokaltog/vim-powerline.git ~/tmp/vim-powerline

# 3. which fonts are available to patch
fc-list

# 4. Install fontforge
sudo yum install fontforge

# 5. Patch font
cd ~/tmp/vim-powerline/fontpatcher
cp /usr/share/fonts/liberation/LiberationMono-Regular.ttf .
fontpatcher LiberationMono-Regular.ttf
cp LiberationMono-Regular-Powerline.ttf ~/.fonts/
sudo fc-cache -vf ~/.fonts/

# 6. Now any monotype font will work properly


# ----------------------------------------------------------------------------
#                                untested
# ----------------------------------------------------------------------------
set pastetoggle=
that will make `set paste` on pasting and `set nopaste` when it's done..




# ----------------------------------------------------------------------------
#                                history
# ----------------------------------------------------------------------------
q: # show command history
Ctrl-c Ctrl-c to exit


# ----------------------------------------------------------------------------
#                                Plugins
# ----------------------------------------------------------------------------

#** Tabular
Tab /=    # align on =


" -------------------------------------------------------------
"                              vim setup
" ------------------------------------------------------------
# Useful plugins
tpope/vim-pathogen
tpope/vim-fugitive
mileszs/ack.vim
chriskempson/base16-vim 
moll/vim-bbye
jpetrie/vim-counterpoint
itchyny/lightline.vim
mtth/scratch.vim
altercation/vim-colors-solarized
christoomey/vim-tmux-navigator
txtfmt : to make arbitrary highlighting
note   : note taking


" -------------------------------------------------------------
"                           Nerd Tree
" -------------------------------------------------------------
git clone https://github.com/scrooloose/nerdtree.git

# close nerdtree window
:NERDTreeClose


" -------------------------------------------------------------
"                            Info
" -------------------------------------------------------------

:scriptname              # All loaded scripts

Note: set command has three variants "set", "setlocal" and "setglobal"
:set <option> ?          # check current value of any option
:set runtimepath         # All directories to look for stuff
:set filetype?           # which plugin is highlighting the file
:setlocal syntax?        # syntax file being used
:verbose set ft ?        # current filetype and who set it
:verbose set foldcolumn? # which script set foldcolumn option

:e $MYVIMRC              # open vimrc from within vim

Ctrl-g                  relative path of current file
1 Ctrl-g                full path of current file

:echo expand('#')       alternate file, see help _#
:echo expand('%')       current file, see help _%
:echo has('clipboard')  check vim compile time options




" -------------------------------------------------------------
"                   Create your own syntax file
" -------------------------------------------------------------
1. Create file ~/.vim/bundle/hlp.vim/ftdetect/hlp.vim
    au BufRead,BufNewFile *.hlp set filetype=hlp
2. Create file ~/.vim/bundle/hlp.vim/syntax/hlp.vim


" -------------------------------------------------------------
"                          Sessions
" -------------------------------------------------------------
" Save current state as session
:mks ~/.vim_sessions/mysession.vim

" Load a saved session
:source ~/.vim_sessions/mysession.vim

" Start vim with session
vim -S ~/.vim_sessions/mysession.vim


" -------------------------------------------------------------
"                          Register
" -------------------------------------------------------------
" copy from register to the command line
Ctrl-r Ctrl-w                 insert the word under cursor in command line,
Ctrl-r {reg}            insert content of register. If text has control characters this may have unexpected effect.
Ctrl-r Ctrl-r {reg}     don't interpret control characters in register when pasting to cmd line


:reg              " show content of all registers
:reg a b c        " show content of registers a,b and c

Manually change the value of a register
:let @/="the"

".  dot register stores the last inserted text, you can use it to insert the
    same text again
"=
    evaluate an expression and insert the result at cursor
    INSERT mode: CTRL-R =<expression> <CR>
    NORMAL mode: "=<expression> p



" -------------------------------------------------------------
"                          Paths
" -------------------------------------------------------------
%  relative path of current file
   %:t      name of current file
   %:p:h    directory of current file



" -------------------------------------------------------------
"              Working with external commands
" -------------------------------------------------------------
Run external command
:! wc %         run external command on file (%)

Read command output
:r ! ls

Filter text through external command
:.!wc           filter current line through external command
:20,25 ! rot13  filter range
vip: !wc -w     select paragraph and send it to wc -w

!!sh            same as ":.!sh", execute the cmd on current line



" -------------------------------------------------------------
"                          operators
" -------------------------------------------------------------
{operator}{count}{motion}
{operator}{i/a}{text-object}  # see section below for text objects

d2w         operator d, count 2, motion word
d5j         delete to 5 lines downwards
df'         delete to first occurance of ' including the character itself
dt'         delete to first occurance of ' not including the character itself


useful operators

c   change
y   yank
=   format
g~  toggle case
d   delete
p   paste
gU  make uppercase
gu  make lowercase
>   shift right
<   shift left
gq  format lines

Note: In visual mode the operator just operates on the selected text. We can think of the selected
text as the text-object


" -------------------------------------------------------------
"                          text objects
" -------------------------------------------------------------
{i|a}{text-object-id}
a  all or around - include boundary which could be space, quote, brackets etc
i  inner - without surrounding space, bracket etc that create the text-object

some text object identifiers

w           word
p           paragraph
b or (      block surrounded by ( )
B or {      block surrounded by { }
" or '      quoted text
< or >      block surrounded by < >
[ or ]      block surrounded by [ ]
t           tag

daw         delete word and trailing white spaces
da"         delete something in double quotes, including the double quote
di"         delete something in double quotes, not including the double quote
da}         delete block surrounded by { }
da{
daB
dat         delete entire HTML/XML text including start and end tags
cit         change text inside HTML tags
vit         or vat, select inside html/xml tags. Use o to jump between ends of selection
vip         select to next blank line (v {inside}{paragraph}



" -------------------------------------------------------------
"                      Tagbar
" -------------------------------------------------------------
s     - change sort order
space - show prototype in command line


" -------------------------------------------------------------
"                      Installing Plugins
" -------------------------------------------------------------
:helptags ~/.vim/doc



" -------------------------------------------------------------
"                      Movements
" -------------------------------------------------------------
[{      jump to { at start of block     ( [ + Shift [ )
[I:     prototype of the function in the included header files

# Fast cursor movement
# -------------------
H     # top of screen
M     # middle of screen
L     # bottom of screen

89G   # Go to line 89
30|   # Jump to column 30
`.    # move to last edit position

^E - scroll the view-port down
^Y - scroll the view-port up
^F - scroll down one page
^B - scroll one page up

Fast text Movement
------------------
zt or zENTER: make the line with the cursor the top line of the screen.
zz or z.    : center
zb or z-    : bottom
zs and ze   : move document like the hand tool in acrobat zs moves rigth
              and ze moves left
zh and zl   : scroll right,left by character
zH and zL   : scroll right, left by half a screen
Note        : use g^ and g$ instead of ^ and $ when the document is scrolled

Matching Bracket
-----------------
%



" -------------------------------------------------------------
" Global  [https://vim.fandom.com/wiki/Power_of_g]
" -------------------------------------------------------------
:g/pattern/cmd          Execute Ex command cmd on lines matching pattern
:g!/pattern/cmd         Execute Ex command cmd on lines *not* matching pattern

:g/pattern/z#.5         # display 5 context lines
:g/pattern/z#.5|echo "========"
:g/pattern/d            # delete all lines with pattern
:g!/pattern/d           # delete all lines that do not match pattern
:v/pattern/d            # delete all lines that do not match pattern
:g/^\s*$/d              # delete all blank lines
:g/^/put =\"\n\"        # double space file
:g/^/put _              # double space file, put blackhole register
:g/pattern/t$           # copy lines matching pattern to end of file
:g/pattern/m$           # move all lines matching pattern to end of file
:g/pattern/y A          # copy matching lines to register A
:.,$g/^\d/exe "normal! \<C-A>"
                        # Increment each number at the start of line
:g/^pattern/s/$/mytext  # Add text to end of line that begins with pattern
:g/pattern/nomal @q     # run macro q on each matching line
:g/pattern1/s/pattern2/string/gi
                        # in lines matchin pattern1 replace pattern2 with string
:v/./,/./-g             # compress multiple blank lines to a single blank line
:%s/^\_s\+$/\r/g         # another way to collapse empty lines


:%g/^a/-1join     join lines starting with character 'a' to previous line
:%g/^ *$/d        delete empty lines
:g/^$/d           delete all blank lines
:g/^\s\+$/d       remove all lines with only whitespace (space or tab)
:g/^\s*$/d        remove all lines with only whitespace or nothing
:%v/vim/m 1       move lines not matching the word 'vim' to line 1
:%g/^a/+1d        delete lines after the ones starting with character 'a'

HELP
:help ex-cmd-index      # list of ex commands useful for :g
:help 10.4              # :g or :global command
:help multi-repeat      # :g and :v commands



" -------------------------------------------------------------
" Using help
" -------------------------------------------------------------
:helpgrep {pattern}     # use \c to ignore case, :cn next :cp previous
    then navigate using :cn :cp :cwindow



" -------------------------------------------------------------
" pipe, redirect, capture output of ex commands
" -------------------------------------------------------------
:redir @a   # start redirect to register a
:g/GRP_     # all output copied to a
:redir END  # stop redirecting
:new        # create a new window
:put! a     # paste into new window

append, write selection to file
:w filename.txt
:w >> filename.txt
:w! filename.txt


" -------------------------------------------------------------
" sort
" -------------------------------------------------------------
:sort u                 uniq
:sort /[^,]*,/          sort on what comes after the pattern, here the second comma separated field
:sort /\a\a\a/ r        sort on pattern. first 3 letters of line (because of r)
:sort!                  reverse sort order
:sort n                 sort on first decimal number in each line



" -------------------------------------------------------------
" calculate, math
" -------------------------------------------------------------
insert mode: <C-r>=7*7<CR>
normal mode: "=1+3<Enter>p

convert hex to dec.
echo 0xabc

add, subract, multiply
echo 0x10 + 3

get hex code of character under cursor in normal mode
g8


" -------------------------------------------------------------
" Remove color codes, bash color codes
" -------------------------------------------------------------
%s/\%x1b\[?*[0-9;]*[HKlhmGP]//g
%s/\e[>=]//g




" -------------------------------------------------------------
" Vim 8 native plugin manager
" -------------------------------------------------------------
~/.vim/pack/plugins/start       " loaded at startup, the name 'plugins' can be anything, only
                                " > 'start' directory is important
~/.vim/pack/plugins/opt         " loaded with 'packadd' e.g: :packadd DrawIt
~/.vim/pack/themes/opt          " themes, such as vim-colors-solarized, the name 'themes' is
                                  > for user, vim only looks at the 'opt' directory
~/.vim/pack/syntax/start        " syntax files, could be under plugins, but just for organization

" Install a plugin
cd ~/.vim/pack/plugins/start/
git clone https://github.com/ycm-core/YouCompleteMe.git
:helptags ~/.vim/pack/plugins/start/YouCompleteMe

" Remove plugin
rm -r ~/.vim/pack/plugins/start/YouCompleteMe

" Update plugin
cd ~/.vim/pack/plugins/start/YouCompleteMe
git pull origin master





" -------------------------------------------------------------
" Special characters in ed commands
" -------------------------------------------------------------
%   current filename
##  current argument list
:p  convert to absolute path
:h  head, last component and separator removed
:t  tail, last component of the name




" -------------------------------------------------------------
" One Vim
" -------------------------------------------------------------
gvim --remote-silent
gvim --remote-tab
change to directory of current file
:lcd %:h<CR>



" -------------------------------------------------------------
" Saved
" -------------------------------------------------------------
s#\v(Duplicate flows[^0-9]+)(\d+)(, flow)(\d+)#\=printf("%s%d(%d,%d)%s%d(%d,%d)", submatch(1), submatch(2),
            submatch(2)/2, submatch(2)%2, submatch(3), submatch(4) , submatch(4)/2, submatch(4)%2)#

s#\v(^Predict flow )(\d+)(.*$)#\=printf("%s%d(%d,%d)%s", submatch(1), submatch(2), submatch(2)/2, submatch(2)%2, submatch(3))#


" convert hex to decimal
s/[a-f0-9]\+$/\=printf("%d", str2nr(submatch(0),16))/

" convert hex number to ipv4 address
s/addr-\(..\)\(..\)\(..\)\(..\)/\=printf("%d.%d.%d.%d",
        str2nr(submatch(1),16), str2nr(submatch(2),16),
        str2nr(submatch(3),16),
        str2nr(submatch(4),16))/

" move blocks containing address in appinfo2ip dump to top
/saddr 192.168.1.125^M}m1?^key:^M:.,'1t0^M'1


" convert peerkey:<hex-ip:decimal-port> to dotted ip address
:%s/peerkey:\(..\)\(..\)\(..\)\(..\):\(\d\+\)/\=printf("%s
        (%d.%d.%d.%d-%d)",submatch(0), str2nr(submatch(1),16),
        str2nr(submatch(2),16),str2nr(submatch(3),16),
        str2nr(submatch(4),16),str2nr(submatch(5),16))/

"  convert addr-<hexIP>-<hexPort> to dotted ip and decimal port
:%s/addr-\(..\)\(..\)\(..\)\(..\)-\(....\)/\=printf("%s
        %d.%d.%d.%d-%d",submatch(0), str2nr(submatch(1),16),
        str2nr(submatch(2),16),str2nr(submatch(3),16),str2n
        r(submatch(4),16),str2nr(submatch(5),16))/



" -------------------------------------------------------------
" cool features
" -------------------------------------------------------------
" Open remote file with scp
:e scp://remoteuser@server.tld//absolute/path/to/document

" Find a man page
:runtime! ftplugin/man.vim
:Man csh
:Man 3 echo
shift + k

insert command <c-r>=
example: run x.py and insert its output at cursor location
:imap <c-j>d <c-r>=system('/tmp/x.py')<cr>



# -----------------------------------------------------------------
# shell, Terminal
# -----------------------------------------------------------------
:sh                 a shell inside vim
:terminal           or :term, new terminal as a horizontal split
:vert :terminal     terminal as vertical split
Ctrl-w  N           terminal-normal-mode
i                   back to regular terminal mode from terminal-normal
Ctrl-w  :           terminal-command-mode
Ctrl-w  ""          paste
Ctrl-w  "{reg}      paste register
Ctrl-w  :display    see all available registers



" -------------------------------------------------------------
" Explore
" -------------------------------------------------------------
Lexplore
enter           open file in preview window
-               up directory
qb              List bookmarked directories (query bookmark)
qf              quick info about the file
mf              mark file / Unmark file
:MF *c          mark a group of files
mF              Unmark all marked files
:MT [dir]       set move/copy target directory
gb              go back to previous directory
gn              go to directory under cursor
gx              go to URL under cursor
:NTree [dir]    like cd
gh              show / hide files starting with '.'
D               delete file
X               run file
md              diff marked files

copy file:
mt <target-dir>
mf <file-to-copy>
mc

move file:
mt <target-dir>
mf <file-to-move>
mm

:Rexplore       return to explorer from editing

p               when using Vexplore, Sexplore etc, open file in preview window


" -------------------------------------------------------------
"                    Overwrite functionality
" -------------------------------------------------------------
select with gh <arrow keys>
gh      character wise select
gH      line wise select




" -------------------------------------------------------------
"                    XML / HTML files
" -------------------------------------------------------------
" enable matchit.vim in .vimrc
packadd! matchit

" use text objects
dat   delete entire HTML/XML text including start and end tags
cit   change text inside HTML tags
vit   or vat, select inside html/xml tags. Use o to jump between ends of selection

" pass through external tidy filters
:% ! xmllint --format --noblanks -
:% ! tidy -xml -iq -w 90 -raw



" -------------------------------------------------------------
"                    CSV VIM
" -------------------------------------------------------------
:WhatColumn         in which column is the cursor
:NrColumns          how many columns are there
:ArrangeColumn
:DeleteColumn 2
:Header 2           Fix first two rows as column heading. default is first row
:Header!            Hide header lines
:Sort 3             Sort on column 3
:Sort 3f            Numeric sort on floating point
:Column a           Copy entire column to register a
:MoveColumn 1 $     Move column to end
:SumCol 2
:NewRecord [count]  Add new line

L                   next col
H                   prev col
K                   up within same col
J                   down within same col

:Analyze 3
:VertFold [<nr>]                            Hide some columns
:VertFold!                                  Undo vert fold
:AddColumn [n] [count]                      add <count> columns after column number <n>
:Substitute [col]pattern/string/flags       search and replace in column
:CountCol [n] [distinct]                    number of [distint] values in column number <n>
:MaxCol
:MinCol
:AvgCol
:PopVarCol                                  population variance
:SmplVarCol                                 Sample variance
:PopStdCol                                  population standard deviation
:SmplStdCol                                 Sample standard deviation
:SearchInColumn [<nr>] /{pat}/



DrawIt
----------------------------------------------------------------------
<space>         toggle draw/erase



" -------------------------------------------------------------
"                    FUGITIVE
" -------------------------------------------------------------
:Git blame [file]
:Gedit HEAD~3:%             loads the current file as it existed 3 commits ago.
:Gedit main:file2           load file2 from branch main

:Gvdiffsplit!               diff with staged version of the file, !=keep current file in focus
:Gvdiffsplit main           diff with branch main
:only                       to close diff

:Gread                      variant of "git checkout -- filename", can be undone with u
:Gwrite                     git add with working tree file. git checkout with index file

:G                          same as :Git, use g? for help on what to do here
:G difftool -y [args]       open all changed file in different tabs, [args] is any git diff arg
:tabo                       close all other tabs

Things to do in :G
=   toggle inline diff
dv  Perform :Gvdiffsplit on the file under cursor
    if there is merge conflict, it opens 3 merge windows
dq  Close all but one diff buffer, and :diffoff! the last one;
d?  Show help
g?  show help
go  open file in vertical split
)   jump to next file, huk, revision

## MERGING ##
In file with merge conflicts
Gvdiffsplit!
d2o     take change from left window
d3o     take change from right window
only    close diff


NOTE: The following is reversed for rebase which is the default for me
Left window     File in the target branch, the branch taking-in the changes
Middle window   The working file
Right window    File in the incoming branch, the branch being merged (source of new changes)

<<<<<<< HEAD
what was in the local branch
=======
what happened after merging from remote branch
>>>>>>>


## Log ##
0Gclog                      log of current file
Git log --oneline
Gllog                       location list

:Git log --patch -- filename
:vertical Git log -p -- %
Gclog --name-only -- %:p


" -------------------------------------------------------------
"                    TAGBAR
" -------------------------------------------------------------
s     - change sort order
space - show prototype in command line

Add new filetype:
1. Create a parser definition for ctags:
   Edit file ~/.ctags.d/myhelp.ctags

  --langdef=myhelp
  --map-myhelp=.mhlp

  --kinddef-myhelp=s,section,section
  --mline-regex-myhelp=/(^[a-zA-Z0-9 ]+)\s*-+$/\1/s,section/{mgroup=1}

2. Check parser is working using this command
   ctags -f - --format=2 --excmd=pattern --extras= --fields=nksaSmt my.mhlp
   Heading1        my.mhlp /^Heading1$/;"  s       line:1
   Heading2        my.mhlp /^Heading2$/;"  s       line:8

3. Edit .vimrc file
   let g:tagbar_type_myhelp = {
       \ 'ctagstype' : 'myhelp',
       \ 'kinds' : [
           \ 's:section'
       \ ],
       \ 'sort' : 0
   \ }

4. Open myhelp file and set filetype.
   :set filetype=myhelp

5. tagbar should work now

6. debugging:
   what parser will be used for a given file
   ctags --print-language srtp.txt

   mapping of file extenstions to language
   ctags --list-maps

   languages understood by ctags
   ctags --list-languages



" -------------------------------------------------------------
"                    .VIMRC commands
" -------------------------------------------------------------

Setting options
:set number                            
:set number?                           check current value of option
:set number!                           toggle a boolean option
:set numberwidth=40                    set a non-boolean option
:setlocal number                       set option for this buffer only


Mapping, never use map, nmap, vmap, imap because they are recursive
:noremap <c-d> dd                      normal and visual mode Ctrl+d mapped to dd
:noremap <space> viw                   normal and visual mode Space-key mapped to "select word"
:nnoremap \ dd                         normal mode only
:vnoremap \ U                          visual mode only, upper case selection
:inoremap <c-d> <esc>ddi               insert mode mapping, delete line
:nmap                                  show normal-mode key mapping
:nnoremap <buffer> <leader>x dd        key mapping for this buffer only


operator pending mapping
:onoremap p i(                        now dp will delete parameters inside the '(' and ')'

abbriviations
iabbrev waht what                      works in insert mode only


Autocommands
:help autocmd-events
:autocmd BufNewFile * :write           BufNewFile   event to watch for 
                                       *            filter for event for example *.txt
                                       :write       The command to run 
:autocmd BufNewFile,BufRead *.html setlocal nowrap   | "Multiple events 



Other
exists(g:syntax_on) " is global variable 'syntax_on' defined?

<CR>                " carriage return see more unprintable-characters :help keycodes
<silent>            " after nmap, causes the mapping not to echo any commands it is executing
s/\<./\u&/g         " upper case first letter of word


line continuation marker: single backslash at the start of line
call SetName(
\             first_name,
\             middle_initial,
\             family_name
\           )
multiple commands in a single line
echo "Starting..." | call Phase(1) | call Phase(2) | echo "Done"


Always use normal! because plane normal takes mappings into account
normal does not understand <cr> <esc> etc.
:execute "normal! mqA;\<esc>`q"

grep the word 
:nnoremap <leader>g :silent execute "grep! -R " .  shellescape(expand("<cWORD>")) . " ."<cr>:copen<cr>


Paths
expand('%')                                 " relative path of current file
expand('%:p')                               " absolute path of current file
fnamemodify('foo.txt', ':p')                " absolute path of foo.txt
globpath('.', '*')                          " all files and dirs in current dir
split(globpath('.', '*.txt'), '\n')         " all txt files as list


Examples
---------------------------------

" change each line use as: :1,3call Change_lines('50')
function! g:Change_lines(val)
    call setline('.', substitute(getline('.'), '\d\+$', a:val, ''))
endfunction


" change last digits on each line in range
function! g:Change_lines(val) range
    let l:lnum = a:firstline
    let l:val= a:val
    while l:lnum < a:lastline
        call setline(l:lnum, substitute(getline(l:lnum), '\d\+$', l:val, ''))
        let l:val+=1
        let l:lnum+=1
    endwhile
endfunction




Help
----------------------------------------------------------------------
ins-special-keys        Special keys in insert mode
vim-variable            :help vim-variable, predefined variables

